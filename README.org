#+TITLE: Emacs Configuration
#+PROPERTY: header-args :tangle config.el
#+STARTUP: inlineimages show2levels

* Table of contents                                                   :TOC_3:
- [[#introduction][Introduction]]
  - [[#what-is-this-and-who-is-it-for][What is this and who is it for?]]
  - [[#dependencies][Dependencies]]
  - [[#installation][Installation]]
  - [[#custom-keybindings][Custom Keybindings]]
- [[#file-early-init][File: Early Init]]
  - [[#file-header][File Header]]
  - [[#start-time-optimizations][Start time optimizations]]
  - [[#user-interface][User Interface]]
  - [[#file-footer][File Footer]]
- [[#file-init][File: Init]]
  - [[#file-header-1][File Header]]
  - [[#define-file-names][Define file names]]
  - [[#load-config-file][Load config file]]
    - [[#method-1-tangle-on-save-and-load-pre-parsed-config-file][Method 1: tangle on save and load pre-parsed config file]]
    - [[#method-2-always-parse-config-file-on-load][Method 2: always parse config file on load]]
  - [[#file-footer-1][File Footer]]
- [[#file-main-configuration][File: Main Configuration]]
  - [[#file-header-2][File Header]]
  - [[#setup][Setup]]
    - [[#enforce-minimum-emacs-version][Enforce minimum Emacs version]]
    - [[#enable-debug-mode-while-loading-config][Enable Debug mode while loading config]]
    - [[#package-management][Package management]]
    - [[#organize-configuration-directory][Organize configuration directory]]
    - [[#system-path][System Path]]
    - [[#startup-profiler][Startup Profiler]]
    - [[#use-emacs-with-server-client-configuration][Use Emacs with server-client configuration]]
  - [[#appearance][Appearance]]
    - [[#font][Font]]
    - [[#theme][Theme]]
  - [[#functions-and-minor-modes][Functions and Minor modes]]
    - [[#custom-functions][Custom Functions]]
    - [[#function-aliases][Function Aliases]]
    - [[#minor-modes][Minor modes]]
  - [[#keybindings][Keybindings]]
    - [[#change-keybindings-scheme][Change keybindings scheme]]
    - [[#global-keybindings][Global Keybindings]]
  - [[#defaults][Defaults]]
    - [[#general-preferences][General Preferences]]
    - [[#indentation][Indentation]]
    - [[#tabs][Tabs]]
    - [[#scrolling][Scrolling]]
    - [[#fringe-margin-and-line-numbers][Fringe, Margin and line numbers]]
    - [[#backup-autosave-and-lockfiles][Backup, Autosave and Lockfiles]]
    - [[#desktop-session][Desktop session]]
    - [[#directory-local-variables][Directory local variables]]
    - [[#searching][Searching]]
    - [[#window-splits][Window Splits]]
  - [[#external-features][External Features]]
    - [[#icon-integration][Icon integration]]
    - [[#project-management][Project Management]]
    - [[#workspaces][Workspaces]]
    - [[#file-explorer][File Explorer]]
    - [[#dashboard][Dashboard]]
    - [[#modeline][Modeline]]
    - [[#search-across-directories][Search Across Directories]]
    - [[#interactive-visual-replace][Interactive Visual Replace]]
    - [[#org-mode][Org mode]]
    - [[#modal-editing][Modal editing]]
    - [[#spellcheck][Spellcheck]]
    - [[#code-completion][Code Completion]]
    - [[#emacs-completion-framework][Emacs Completion Framework]]
    - [[#git-integration][Git Integration]]
    - [[#templates-and-snippets][Templates and Snippets]]
    - [[#multiple-cursors][Multiple Cursors]]
    - [[#presentations][Presentations]]
    - [[#move-text][Move Text]]
    - [[#hydras][Hydras]]
    - [[#pdf-viewer][PDF Viewer]]
    - [[#code-linter][Code Linter]]
    - [[#spacemacs-esque-menu][Spacemacs-esque menu]]
    - [[#outline-sidebar][Outline sidebar]]
    - [[#other-additions][Other additions]]
  - [[#language-modes][Language Modes]]
    - [[#c][C#]]
    - [[#csv][CSV]]
    - [[#dockerfile][Dockerfile]]
    - [[#dotenv][Dotenv]]
    - [[#git][Git]]
    - [[#html][HTML]]
    - [[#java][Java]]
    - [[#json][JSON]]
    - [[#review-latex][REVIEW Latex]]
    - [[#lua][Lua]]
    - [[#markdown][Markdown]]
    - [[#php][PHP]]
    - [[#shell-script][Shell Script]]
    - [[#python][Python]]
    - [[#terraform-hcl][Terraform (HCL)]]
    - [[#yaml][YAML]]
  - [[#personal-settings][Personal Settings]]
  - [[#experimental-snippets--work-in-progress][Experimental Snippets + Work in Progress]]
    - [[#org-beautify-symbols][org beautify symbols]]
    - [[#word-navigation][word navigation]]
    - [[#stuff-i-need-to-try-that-might-improve-scrolling][stuff I need to try that might improve scrolling.]]
    - [[#make-tab-line-empty][make tab-line empty]]
    - [[#emacs-server][Emacs server]]
    - [[#system-notifications][system notifications]]
    - [[#ledger][ledger]]
    - [[#agenda-todo-list---ignore-scheduled-and-deadline][agenda todo list - ignore scheduled and deadline]]
    - [[#export-org-agenda-to-ics-file-for-google-calendar][export org agenda to .ics file for Google calendar]]
    - [[#dired-sidebar-test][dired-sidebar test]]
    - [[#indent-guides][indent guides]]
    - [[#company-flyspelel][company-flyspel.el]]
    - [[#dired-sort-menu][dired-sort-menu]]
    - [[#check-host-os][check host OS]]
    - [[#format-org-files---move-planning-to-top-of-heading][format org files - move planning to top of heading]]
    - [[#color-theme-examples-and-research][Color theme examples and research]]
    - [[#vim-and-ryo-modal-keybindings][Vim and Ryo-modal keybindings]]
    - [[#git-graph][Git Graph]]
    - [[#bookmarks-and-marks][bookmarks and marks]]
    - [[#experimental-keybind-changes][experimental keybind changes]]
    - [[#theme-faces-and-colours][Theme Faces and Colours]]
  - [[#file-footer-2][File Footer]]
- [[#fixes-improvements-and-todos][Fixes, Improvements and TODOs]]

* Introduction
** What is this and who is it for?

Just as Spacemacs and Doom Emacs try to combine the best parts of Emacs and Vim, this is my attempt at a configuration that combines Emacs and VSCode.

This Emacs configuration allows you to use Org mode while still having access to "modern" keybindings.
Many of the Emacs keybindings are replaced with what I consider "standard" keybinds, like those you would find in Sublime Text, Atom or VSCode. Likewise, many of the features you would expect from some of these editors are also implemented here.
The goal of this configuration is to provide a comfortable experience editing Org mode files to programmers that are accustomed to modern text editors.

Also, this Emacs configuration is not a window manager, nor does it try cram as many features as possible within Emacs. I will use Emacs to edit text and nothing more.
So I only plan on installing packages that either help with programming or add features to org-mode.

** Dependencies

By default, in order for everything to work correctly, you should have the following installed on your system:
  - ripgrep
  - fd
  - fzf
  - aspell (or hunspell)
  - git
  - pandoc (or some other markdown parser)
  - python
  - vmd (node.js package)
  - decktape (node.js package)
  - some icon fonts

If one or more packages are missing, I cannot guarantee everything will work properly.

Some Tips:
  - Some features like markdown previewing and spellchecking have multiple alternatives available.
  - In general, if a dependency is missing, Emacs should be able to detect that and show a warning.
  - If you want to know where and why a system package is necessary, search for the =ensure-system-package= keyword.

** Installation

Eventually, this config will work on Windows but, for now, only Linux is supported.

(Optional) backup your existing configuration:

#+begin_src shell :tangle no

cp ~/.emacs.d ~/.emacs.d.backup

#+end_src

Installation:

#+begin_src shell :tangle no

mkdir ~/.emacs.d/
cd ~/.emacs.d/
git clone https://github.com/kyukee/emacs-config.git

#+end_src

Then, after opening Emacs for the first time, open the command menu with =M-x= and run the function ~my/first-startup~.

** Custom Keybindings

*WARNING*
Most of the keybinds are missing or out of date...
I'll do something about it eventually...

The conversion to use "modern" keybinds is mostly dealt with by [[https://github.com/darkstego/wakib-keys][wakib-keys]].
I customized the commands and changed a few keys but it's still similar to the default package.

The following image shows all the keys you need to know to get started:

#+ATTR_ORG: :width 900
[[./base/docs/keyboard-layout-images/keyboard-layout-ctrl.png]]

The wakib-keys package defines a lot more bindings that are more oriented towards speed and productivity.
If you're interested, go check it out.

# How to modify layout images:
#  - go to http://www.keyboard-layout-editor.com/#/
#  - import json file
#  - make changes
#  - use browser zoom in and take screenshot
# Notes:
#  - firefox screenshot tool can easily select correct area (by selecting the div)
#  - website export function exists but doesn't work very well

Notes:
  - If you know M-x and C-h, you're already halfway there. Even if you forget something, knowing these two bindings allows you to discover anything you need.
  - The modeline segments can be hovered on to show information and clicked to perform certain actions.
  - In a lot of modes, you can use =q= to quit and =?= to show help

* File: Early Init
** File Header

Emacs HEAD (27+) introduces early-init.el, which is run before init.el, before package and UI initialization happens.

#+begin_src emacs-lisp :tangle early-init.el
;;; early-init.el --- Emacs Early Init File          -*- lexical-binding: t -*-

;;; Commentary:
;; GNU Emacs Configuration - Early Init

;;; Code:

#+end_src

** Start time optimizations

#+begin_src emacs-lisp :tangle early-init.el

;; A common optimization is to temporarily reduce the frequency of garbage collection during initialization.
(setq gc-cons-threshold most-positive-fixnum)

;; FileNameHandler
(defvar file-name-handler-alist-original file-name-handler-alist)
(setq file-name-handler-alist nil)

;; Restore values after startup
(add-hook 'after-init-hook
           (lambda ()
             (setq gc-cons-threshold (* 16 8 1024 1024) ; 16MB
                   file-name-handler-alist file-name-handler-alist-original)))

#+end_src

** User Interface

For the GUI changes that deserve to be in early-init. It is more efficient to disable UI elements before they are even loaded than to load them with the wrong configuration and then change them.

#+begin_src emacs-lisp :tangle early-init.el

;; Only show cursor in the active window.
(setq-default cursor-in-non-selected-windows nil)

;;Default frame position
(setq default-frame-alist
      `((height . 60) (width . 100)))

;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)

;; show column number alongside line number
(column-number-mode 1)

;; display relative line numbers
(global-display-line-numbers-mode)
(setq display-line-numbers-type 'visual)

;; highlight current line
(global-hl-line-mode +1)

;; avoid flashing the default emcas modeline while starting
(setq mode-line-format nil)

;; Do not resize the frame at this early stage.
(setq frame-inhibit-implied-resize t)

#+end_src

** File Footer

#+begin_src emacs-lisp :tangle early-init.el

;;; early-init.el ends here

#+end_src

* File: Init
** File Header

#+begin_src emacs-lisp :tangle init.el
;;; init.el --- Emacs Init File          -*- lexical-binding: t -*-

;;; Commentary:
;; GNU Emacs Configuration - Initialization File

;;; Code:

#+end_src

** Define file names

#+begin_src emacs-lisp :tangle init.el

(defvar *config-file* (expand-file-name "README.org" user-emacs-directory)
  "The configuration file.")

(defvar *config-file-tangled* (expand-file-name "config.el" user-emacs-directory)
  "The configuration file, after being tangled.")

#+end_src

** Load config file
*** Method 1: tangle on save and load pre-parsed config file

After the first time that config.el is created, this will no longer tangle the config file.
This method is slightly faster than just using org-babel-load-file.
This is most effective when you have a hook to tangle the config file every time you save it.

#+begin_src emacs-lisp :tangle init.el

(load-file (expand-file-name "base/resources/tangle-patch.el" user-emacs-directory))

;; If tangled elisp exists then load it, otherwise tangle the Org file and load it
(if (file-exists-p *config-file-tangled*)
    (load-file *config-file-tangled*)
  (org-babel-load-file *config-file*))

#+end_src

*** Method 2: always parse config file on load                   :notangle:

Always parse the config file when starting emacs.
This can be useful if recovering from errors in the config file is a concern.
The downside is that =org-babel-tangle= can take several seconds to complete.

#+begin_src emacs-lisp

;; load config.el
(org-babel-load-file *config-file*)

#+end_src

** File Footer

#+begin_src emacs-lisp :tangle init.el

;;; init.el ends here

#+end_src

* File: Main Configuration
** File Header

#+begin_src emacs-lisp
;;; config.el --- Emacs Configuration File          -*- lexical-binding: t -*-

;;; Commentary:
;; GNU Emacs Configuration - Startup file

;;; Code:

#+end_src

** Setup
*** Enforce minimum Emacs version

#+begin_src emacs-lisp

(let ((min-version "27.0"))
  (when (version< emacs-version min-version)
    (error "Gnu Emacs %s or newer is required" min-version)))

#+end_src

*** Enable Debug mode while loading config

Enable debug mode before we make any changes. This makes is easier to figure out errors when they happen.
It only stays active while the config is loading.

#+begin_src emacs-lisp

;; when an error occurs during startup, automatically open debugger
(setq debug-on-error t)

;; disable debugging after startup
(add-hook 'after-init-hook
           (lambda () (setq debug-on-error nil)))

#+end_src

*** Package management
**** Package: straight

straight.el is used to make the init-file the sole source of truth for package operations.

#+begin_src emacs-lisp

(setq straight-use-package-by-default         t
      straight-check-for-modifications        '(find-when-checking))

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+end_src

**** Package: use-package

#+begin_src emacs-lisp

(straight-use-package 'use-package)

;; Configure `use-package' prior to loading it.
(setq use-package-expand-minimally            t
      use-package-compute-statistics          t
      use-package-enable-imenu-support        t
      use-package-verbose                     t)

#+end_src

**** Package: use-package-ensure-system-package

#+begin_src emacs-lisp

(use-package use-package-ensure-system-package)

#+end_src

**** Package: pretty-hydra

nicer syntax for declaring hydras with use-package

#+begin_src emacs-lisp

(use-package pretty-hydra)

#+end_src

**** Notes and basic usage

To install a package temporarily (until you restart Emacs):
- M-x straight-use-package

To install a package permanently, place a call to straight-use-package in your init-file, like:
- (straight-use-package 'el-patch)

To update all packages to their most recent version:
- M-x straight-pull-all

A note about ":init" and ":config".
- init is executed before a package is loaded (even if deferred)
- config is executed after a package is loaded

*** Organize configuration directory
**** Package: no-littering

Make emacs configuration directory more organized and keep it clean.
'no-littering' should be loaded as early as possible since it changes where other packages will save their files.

#+begin_src emacs-lisp

(use-package no-littering)

#+end_src

*** System Path
**** Package: exec-path-from-shell

#+begin_src emacs-lisp

(use-package exec-path-from-shell
  :config
  (exec-path-from-shell-initialize))

#+end_src

*** Startup Profiler
**** Package: esup

This isn't in the same section as the other features because it needs to loaded as early as possible to get accurate results.

One small issue is that it doesn't seem to load the early init file.

#+begin_src emacs-lisp

(use-package esup
  :commands (esup))

#+end_src

**** Package: benchmark-init                                    :notangle:

#+begin_src emacs-lisp

(use-package benchmark-init
  :defer nil
  :config
  (benchmark-init/activate)
  :hook (after-init . benchmark-init/deactivate))

#+end_src

**** Notes and basic usage

When using the =benchmark-init= profiler, just un-comment the line that disables the package.
Comment and un-comment that line to enable/disable the feature.

To see the results, run:
- benchmark-init/show-durations-tabulated
- benchmark-init/show-durations-tree

*** Use Emacs with server-client configuration
**** Package: server

Use emacs with a server/client model.

#+begin_src emacs-lisp

(use-package server
  :config
  (unless (server-running-p) (server-start)))

#+end_src

** Appearance
*** Font

Some of my font options:
  - IBM Plex Mono
  - Cartograph CF

The unit for the 'height' attribute is 1/10pt, which means a height of 100 is 10pt.

#+begin_src emacs-lisp

;; (set-face-attribute 'default nil
;;                      :family "Cartograph CF"
;;                      :height 120)

;; (set-face-attribute 'default nil
;;                      :font "Cartograph CF-12")


;; Set default font
(set-frame-font "-UKWN-Cartograph CF-normal-normal-normal-*-*-*-*-*-m-0-iso10646-1")


;; make font smaller, where necessary
(custom-set-faces
 '(default                    ((t (:height 120))))
 '(line-number                ((t (:height 110))))
 '(line-number-current-line   ((t (:height 110))))
 '(mode-line                  ((t (:height 90))))
 '(mode-line-inactive         ((t (:height 90))))
 '(tab-line-tab               ((t (:height 100))))
 '(treemacs-file-face         ((t (:height 100))))
 '(hydra-posframe-face        ((t (:height 100))))
 '(ivy-posframe               ((t (:height 100)))))

#+end_src

*** Theme

I use a custom theme edited by myself, titled =neon-ocean-sunset=.

Current issues:
  - colors from =C-u C-b= and =M-SPC b b= are based on =outline= faces -> pick better outline/org level colors
  - =general= hydra menu colors -> not enough contrast between green and blue -> cant really do much about it besides picking font-lock faces
  - magit-section-header

#+begin_src emacs-lisp

(add-to-list 'custom-theme-load-path "~/.emacs.d/base/themes/")
(load-theme 'neon-ocean-sunset t)

#+end_src

These are some themes I used before:
  - cyberpunk
  - underwater
  - darktooth
  - tangotango
  - darkburn

To use a theme from an Emacs package:

#+begin_src emacs-lisp :tangle no

(use-package underwater-theme
  :config
  (load-theme 'underwater t))

#+end_src

Note:
  If there are problems with themes conflicting with each other, it may help to use =disable-theme= before switching to another theme.

** Functions and Minor modes
*** Custom Functions

General user created functions.
These functions aren't associated with any package since they only use default emacs functionality.
Functions that depend on an emacs package will be declared alongside their respective package.

**** Functions: Emacs - reload, quit, etc

#+begin_src emacs-lisp

(defun my/reload-init-file ()
  "Reload Emacs cofiguration."
  (interactive)
  (message "Reloading init.el...")
  (load-file user-init-file)
  (message "Reloading init.el... done."))

(defun my/open-init-file ()
  "Open Emacs cofiguration."
  (interactive)
  (message "Opening init.el...")
  (find-file *config-file*)
  (message "Opened init.el... done."))

(defun my/kill-emacs ()
  "Save open buffers, then exit unconditionally."
  (interactive)
  (save-some-buffers nil t)
  (kill-emacs))

(defun my/toggle-fullscreen ()
  "Toggle fullscreen."
  (interactive)
  (toggle-frame-fullscreen))

#+end_src

**** Functions: select and navigate text

#+begin_src emacs-lisp

(defun my/select-current-line ()
  "Select the current line."
  (interactive)
  (beginning-of-line) ; move to end of line
  (set-mark (line-end-position)))

(defun my/genius-beginning-of-line ()
  "Move point to the first non-whitespace character on this line.
If point was already at that position, move point to beginning of line.
If line is empty, indent the line relative to the preceding line."
  (interactive "^")
  (let ((oldpos (point)))
    (back-to-indentation)
    (and (= oldpos (point))
         (progn (move-beginning-of-line nil)
                (when (=
                       (line-beginning-position)
                       (line-end-position))
                  (save-excursion
                    (indent-according-to-mode)))))))

(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

When on a visual line, move to the beginning of the visual line.
If already on the beginning of the visual line, move to first
non-whitespace character of the real line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point  (point))
        (indent-pos  (save-excursion (back-to-indentation)
                                     (point)))
        (beg-pos     (save-excursion (beginning-of-line)
                                     (point)))
        (vis-beg-pos (save-excursion (beginning-of-visual-line)
                                     (point))))
    (if (and (not (= beg-pos vis-beg-pos)) (not (= orig-point vis-beg-pos)))
        (beginning-of-visual-line)
      (if (= orig-point indent-pos)
          (beginning-of-line 1)
        (back-to-indentation)))))

;; for some reason, this workaround is needed. "M-," doesn't work with shift select by default
(defun my/forward-sexp-with-shift-select ()
  "Standard `forward-sexp', but with support for shift select."
  (interactive)
  (setq this-command-keys-shift-translated t)
  (call-interactively 'forward-sexp))

(defun my/backward-sexp-with-shift-select ()
  "Standard `backward-sexp', but with support for shift select."
  (interactive)
  (setq this-command-keys-shift-translated t)
  (call-interactively 'backward-sexp))

;; the "er/expand-region" function could also maybe work
(defun my/extend-region-to-whole-lines ()
  "Extend an active region so that the first and last lines are fully selected.
In the first line of the selected region, extend to beginning of line, and in
the last line of the region, extend to end of line (including final newline)."
  (interactive)
  (let ((curr  (point))
        (beg   (save-excursion (goto-char (region-beginning))
                               (line-beginning-position)))
        (end   (save-excursion (goto-char (region-end))
                               (line-end-position))))
    (if (= end curr)
        (exchange-point-and-mark))
    (goto-char beg)
    (exchange-point-and-mark)
    (goto-char end)))

#+end_src

**** Functions: move, indent and delete text

#+begin_src emacs-lisp

(defun my/delete-word-no-clipboard (arg)
  "If the next character is whitespace, delete all until the first character.
Otherwise, delete characters forward until encountering the end of a word.
With ARG, do this that many times.  ARG can be negative to go backwards.
If ARG is negative, look at previous character instead of next one.
This command does not push text to `kill-ring'."
  (interactive "p")
  (if (or (and (looking-at "[ \t\n]") (> arg 0)) (and (looking-back "[ \t\n]") (< arg 0)))
      (let ((pos (point)))
        (re-search-forward "[^ \t\n]" nil t arg)
        (forward-char (- (cl-signum arg)))
        (if (= pos (point))
            (delete-region
             (point)
             (progn
               (forward-word arg)
               (point)))
          (delete-region pos (point))
          ))
    (delete-region
     (point)
     (progn
       (forward-word arg)
       (point)))))

(defun my/backward-delete-word-no-clipboard (arg)
  "If the next character is whitespace, delete all until the first character.
      Otherwise, delete characters forward until encountering the end of a word.
      With ARG, repeat that many times.
      This command does not push text to `kill-ring'."
  (interactive "p")
  (my/delete-word-no-clipboard (- arg)))

(defun my/indent-region-custom (numSpaces)
  "Indent current line or active region, if one is selected, by NUMSPACES.
      For every line with a selected character, indent from the beggining of the line.
      This means that the first and last line don't need to be completly selected."
  (progn
    ;; default to start and end of current line
    (setq start (line-beginning-position))
    (setq end (line-end-position))

    ;; (if (equal start end)
    ;;     )

    ;; if there's a selection, use that instead of the current line
    (when (use-region-p)
      (setq regionStart (region-beginning))
      (setq regionEnd (region-end))
      (save-excursion                       ; restore the position afterwards
        (goto-char regionStart)                ; go to the start of region
        (setq start (line-beginning-position)) ; save the start of the line
        (goto-char regionEnd)                  ; go to the end of region
        (setq end (line-end-position))         ; save the end of the line
        (setq deactivate-mark nil)             ; re-select the region
        ))
    (indent-rigidly start end numSpaces)   ; indent between start and end
    (setq deactivate-mark nil)))

(defun my/untab-region (N)
  "Unindent all lines in region by N spaces."
  (interactive "p")
  (my/indent-region-custom (- N)))

(defun my/tab-region (N)
  "Indent all lines in region by N spaces."
  (interactive "p")
  (if (active-minibuffer-window)
      (minibuffer-complete)     ; tab is pressed in minibuffer window -> do completion
    (my/indent-region-custom N)))

(defun my/switch-indentation-use-spaces ()
  "Use spaces for indentation."
  (interactive)
  (setq indent-tabs-mode nil))

(defun my/switch-indentation-use-tabs ()
  "Use tabs for indentation."
  (interactive)
  ;; (local-set-key (kbd "TAB") 'tab-to-tab-stop)
  (setq indent-tabs-mode t))

;; depends on doom-modeline-indent-alist
(defun my/set-buffer-indentation-size ()
  "Set indentation width for current buffer."
  (interactive)
  (let ((lookup-var
         (seq-find (lambda (var)
                     (and var (boundp var) (symbol-value var)))
                   (cdr (assoc major-mode doom-modeline-indent-alist)) nil))
        (new-width
         (string-to-number
          (completing-read "Chose tab width: " '("2" "4" "8")))))
    (if lookup-var
        (set lookup-var new-width))
    (setq tab-width new-width)))

;; taken from doom-modeline indentation segment
;; depends on doom-modeline-indent-alist
(defun my/get-buffer-indentation-size ()
  "Get the indentation width for the current buffer."
  (let ((lookup-var
         (seq-find (lambda (var)
                     (and var (boundp var) (symbol-value var)))
                   (cdr (assoc major-mode doom-modeline-indent-alist)) nil)))
    (if lookup-var
        (symbol-value lookup-var)
      tab-width)))

(defun my/check-indentation-type ()
  (if indent-tabs-mode
      "Tabs"
    "Spaces"))

#+end_src

**** Functions: org-mode

#+begin_src emacs-lisp

(defun my/org-content-with-argument ()
  "Choose how many org heading levels are viible."
  (interactive)
  (org-content
   (string-to-number (completing-read "Show content up to level N: " '("1" "2" "3" "4" "5" "6" "7" "8" "9")))))

(defun my/open-file-from-org-dir ()
  "Open one of the files belonging to the main org directory."
  (interactive)
  (counsel-file-jump "" org-directory))

(defun my/anime-info-at-point (start end)
  "Search for an anime title and display its details.
Use text in selected region as input."
  (interactive "r")
  (let* ((search-term (buffer-substring start end)))
    (async-shell-command
     (concat "anime-spy '"
             (completing-read "Search for anime: "
                              (if (region-active-p)
                                  (list search-term)
                                (list "")))
             "'"))))

(defun my/anime-search-at-point (start end)
  "Display a list of anime titles with a matching name.
Use text in selected region as input."
  (interactive "r")
  (let* ((search-term (buffer-substring start end)))
    (shell-command
     (concat "anime-cli '"
             (completing-read "Search for anime: "
                              (if (region-active-p)
                                  (list search-term)
                                (list "")))
             "'")))
  (let* ((wind (get-buffer-window "*Shell Command Output*")))
    (with-selected-window wind
      (progn
        (beginning-of-buffer)))))

(defun my/org-agenda ()
  (interactive)
  "Show custom agenda view, with a normal weekly view plus all NEXT items."
  (org-agenda nil "a"))


#+end_src

**** Functions: org-mode - format org files

Function to format Org file.
Use to format current tree. Add C-u to format whole file.

Useful resource: https://github.com/alphapapa/unpackaged.el#ensure-blank-lines-between-headings-and-before-contents

Notes:
  - There can be more than one empty line before or after a heading's content.
  - Without a prefix, operate on tree. With a prefix, operate on whole buffer.
  - This isn't enforced, but planning lines should appear before any drawers.
  - Think about adding to ~after-save-hook~.

#+begin_src emacs-lisp

(defun my/org-format-fix-blank-lines (&optional prefix)
  "Ensure that blank lines exist between headings and their contents.
Ensures that blank lines exist after each headings's drawers.
Removes blank lines in empty headings.
With prefix, operate on whole buffer."
  (interactive "P")
  (org-map-entries
   (lambda ()
     ;; `org-map-entries' narrows the buffer, which prevents us from seeing
     ;; newlines before the current heading, so we do this part widened.
     (org-with-wide-buffer

      ;; Insert blank line before heading. (Only when previous line isn't another heading)
      (forward-line -1)
      (when (not (org-at-heading-p))
        (goto-char (org-entry-end-position))
        (while (not (looking-back "\n\n" nil))
          (insert "\n")))

      ;; Delete blank lines in empty headings
      (save-excursion
        (forward-line -1)
        (when (not (org-at-heading-p))
          (while (looking-back "\n" nil)
            (forward-char -1))
          (when (org-at-heading-p)
            (delete-blank-lines)))))

     ;; Insert blank lines before heading content
     (let ((end (org-entry-end-position)))
       (forward-line)

       ;; Skip planning lines (Scheduled, Deadline, etc.)
       (while (and (org-at-planning-p)
                   (< (point) (point-max)))
         (forward-line))

       ;; Skip drawers. You might think that `org-at-drawer-p' would suffice, but
       ;; for some reason it doesn't work correctly when operating on hidden text.
       ;; This works, taken from `org-agenda-get-some-entry-text'.
       (while (re-search-forward org-drawer-regexp end t)
         (re-search-forward "^[ \t]*:END:.*\n?" end t)
         (goto-char (match-end 0)))

       (unless (or (= (point) (point-max))
                   (org-at-heading-p)
                   (looking-at-p "\n"))
         (insert "\n"))))

   t (if prefix
         nil
       'tree)))

#+end_src

**** Functions: misc

#+begin_src emacs-lisp

(defun my/first-startup ()
  "Performs all necessary procedures during the first time Emacs is opened."
  (interactive)
  (all-the-icons-install-fonts))

(defun my/set-buffer-large-fringe ()
  "The fringe is set smaller than default because of the git gutter indicators.
Some buffers like magit and bufler use the fringe for indicators and need
more space.  Other buffers that allow folding and unfolding with tab should
also use this."
  (setq left-fringe-width 16
        right-fringe-width 8))

(defun my/set-buffer-dashboard-fringe ()
  "Used to set fringes specifically for the dashboard."
  (setq left-fringe-width 12
        right-fringe-width 12))

;; used as such: (my/pad-string "some string" 15)
;; result: "    some string"
(defun my/pad-string (string size)
  "Pad STRING by adding spaces to the start until SIZE is reached.
If STRING length is smaller than SIZE, do nothing."
  (let* ((padding (- size (length string)))
         (lpad (+ (length string) padding))
         (lformat (format "%%%ds" lpad))
         (rformat (format "%%%ds" (- size))))
    (format rformat (format lformat string))))

(defun my/untabify-whole-buffer ()
  "Convert all indentation in document into spaces."
  (interactive)
  (mark-whole-buffer)
  (untabify (region-beginning) (region-end)))

(defun my/tabify-whole-buffer ()
  "Convert all indentation in document into tabs."
  (interactive)
  (mark-whole-buffer)
  (tabify (region-beginning) (region-end)))

;; change how word navigation functions for some symbols
;; Fixes highlighting errors for < and >
(defun my/modify-word-definitions ()
  "Modify how some symbols are treated to improve word navigation."
  ;; This can be used to treat undescore as a word character
  ;; (modify-syntax-entry ?_ "w")

  ;; When using "show-paren-mode", if code contains an angled bracket (">") is treated as a matching paren, which creates a mismatch.
  ;; This disables matching for the angle bracket character.
  (modify-syntax-entry ?< ".")
  (modify-syntax-entry ?> ".")

  ;; This makes backward-word and forward-word ignore the ' character
  (modify-syntax-entry ?' "."))

;; move/rename current file
(defun my/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting.
This will delete the old version."
  (interactive)
  (let* ((name (buffer-name))
         (filename (buffer-file-name))
         (basename (file-name-nondirectory filename)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " (file-name-directory filename) basename nil basename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(defun my/show-buffer-file-name ()
  "Show the full path to the current file in the minibuffer.
Also copy to clipboard."
  (interactive)
  (let ((file-name (buffer-file-name)))
    (if file-name
        (progn
          (message file-name)
          (kill-new file-name))
      (error "Buffer not visiting a file"))))

(defun my/show-buffer-name ()
  "Show the filename of the current file in the minibuffer.
Also copy to clipboard."
  (interactive)
  (let ((file-name (buffer-name)))
    (if file-name
        (progn
          (message file-name)
          (kill-new file-name))
      (error "Buffer not visiting a file"))))

;; Start emacs without a session and allow manually loading the previous session, if desired.
;; Use /desktop-save-in-desktop-dir/ to save the first session, if there aren't any saved sessions yet.
(defun my/desktop-enable ()
  "Add the buffers from the last saved session to the current one, and enable autosave on quit."
  (interactive)
  (let ((desktop-load-locked-desktop "ask"))
    (desktop-read)
    (desktop-save-mode t))
  (message "Previous session loaded"))

(defun my/open-scratch-buffer ()
  "Switch to scratch buffer, creating it if it doesn't exist."
  (interactive)
  (switch-to-buffer (get-buffer-create "*scratch*"))
  (lisp-interaction-mode))

;; this is also available in the 'crux' package
(defun my/delete-file-and-buffer ()
  "Kill the current buffer and deletes the file it is visiting."
  (interactive)
  (if (y-or-n-p (format "Really delete file? "))
      (let ((filename (buffer-file-name)))
        (when filename
          (if (vc-backend filename)
              (vc-delete-file filename)
            (progn
              (delete-file filename)
              (message "Deleted file %s" filename)
              (kill-buffer)))))
    (message "Canceled file delete.")))

(defun my/set-buffer-line-ending-style ()
  "Change line endings in current buffer."
  (interactive)
  (set-buffer-file-coding-system
   (intern (completing-read "Chose line ending style: " '("unix" "dos" "mac")))))

(defun my/open-external-terminal-here ()
  "Open external terminal"
  (interactive "@")
  (shell-command (concat "kitty --directory \'"
                         (file-name-directory (or load-file-name buffer-file-name))
                         "\' > /dev/null 2>&1 & disown") nil nil))

(defun my/make-file-executable ()
  "Make file open in current buffer executable."
  (interactive)
  (executable-make-buffer-file-executable-if-script-p))

;; 'my/uniq' Helper functions
(defun my/case-fold-string= (a b)
  (eq t (compare-strings a nil nil b nil nil t)))
(defun my/case-fold-string-hash (a)
  (sxhash (upcase a)))
(define-hash-table-test 'my/case-fold
  'my/case-fold-string= 'my/case-fold-string-hash)

;; Equivalent to unix command "uniq -c"
(defun my/uniq (beg end)
  "Print counts of strings in region."
  (interactive "r")
  (let ((h (make-hash-table :test 'my/case-fold))
        (lst (split-string (buffer-substring-no-properties beg end) "\n"
                           'omit-nulls " ")))
    (dolist (str lst)
      (puthash str (1+ (gethash str h 0)) h))
    (setq results (list))
    (maphash (lambda (key val)
               (push (list val key) results))
             h)
    (setq results (sort results (lambda (a b) (> (car a) (car b)))))
    (with-output-to-temp-buffer "*my/uniq*"
      (cl-dolist (val results)
        (princ (format "%s: %s\n" (car val) (car (cdr val))))))))

(defun my/buffer-local-set-key (key command)
  (interactive "KSet key buffer-locally: \nCSet key %s buffer-locally to command: ")
  (let ((oldmap (current-local-map))
        (newmap (make-sparse-keymap)))
    (when oldmap
      (set-keymap-parent newmap oldmap))
    (define-key newmap key command)
    (use-local-map newmap)))

(defun my/latex-compile-makefile-and-open-pdf ()
  "Compile a Latex document using a Makefile and open resulting PDF.
The compilation runs in the background.  If the compilation is successful
the pdf is opened in Emacs, otherwise the compilation error is shown."
  (interactive)
  (let ((filename (file-name-sans-extension buffer-file-name))
        (compilation-exit-code (shell-command "make")))  ;; compile is async, shell-command is synchronous
    ;; check if the exit code is 0, which means there are no errors
    (when (= 0 compilation-exit-code)
      (find-file-other-window (expand-file-name (concat filename ".pdf"))))))

(defun my/convert-pdf-to-png ()
  "Convert PDF to png images."
  (interactive)
  (let* ((pdf-file-name (read-file-name "PDF name: "))
         (pdf-name      (file-name-nondirectory (file-name-sans-extension pdf-file-name)))
         (output-name   (completing-read "Output name: " (list "") nil nil pdf-name)))
    (shell-command
     (concat "pdftoppm '" pdf-file-name "' " output-name " -png"))
    (message (concat output-name ".png successfully created"))))

#+end_src

*** Function Aliases
**** Functions: menu-bar

Give the toggle menu function a nicer name so its easier to find if necessary.

#+begin_src emacs-lisp

(defalias 'toggle-menu-bar 'toggle-menu-bar-mode-from-frame)

#+end_src

**** Functions: bookmarks

Consolidate names for functions related to bookmarks.
These are the function used for bookmarks:

- bookmark-add-or-open
- bookmark-remove
- bookmark-rename

#+begin_src emacs-lisp

(defalias 'bookmark-add-or-open 'counsel-bookmark)
(defalias 'bookmark-remove 'bookmark-delete)

#+end_src

**** Functions: revert-buffer

#+begin_src emacs-lisp

(defalias 'reload-buffer 'revert-buffer)

#+end_src

*** Minor modes

Just like the functions, these minor modes only depend on default Emacs.

**** Minor mode: unsaved-buffer-changes-mode

#+begin_src emacs-lisp

(defun my/highlight-changes-mode-restart ()
  (highlight-changes-mode -1)
  (highlight-changes-mode 1))

(define-minor-mode unsaved-buffer-changes-mode
  "Mode for highlighting unsaved changes in a buffer.
Only starts tracking changes after activation.
Resets after file save."
  :local t
  (if unsaved-buffer-changes-mode
      (progn
        (add-hook 'after-save-hook #'my/highlight-changes-mode-restart)
        (highlight-changes-mode 1))
    (progn
      (remove-hook 'after-save-hook #'my/highlight-changes-mode-restart)
      (highlight-changes-mode -1))))

#+end_src

**** Minor mode: exchange-point-mode

#+begin_src emacs-lisp

(defun my/exchange-point-and-mark-when-cg ()
  (when (region-active-p)
    (exchange-point-and-mark)))

(define-minor-mode global-exchange-point-mode
  "Mode for restoring point position w/ `keyboard-quit' when
a region is active."
  :global t
  (if global-exchange-point-mode
      (advice-add #'keyboard-quit :before #'my/exchange-point-and-mark-when-cg)
    (advice-remove 'keyboard-quit #'my/exchange-point-and-mark-when-cg)))

(global-exchange-point-mode 1)

#+end_src

**** Minor mode: blank-tab-line-mode

#+begin_src emacs-lisp

(define-minor-mode global-blank-tab-line-mode
  "Mode for showing a blank line at the top of the Emacs frame."
  :global t
  (if (equal (type-of tab-line-format) 'string)
      (setq tab-line-format '(:eval (tab-line-format)))
    (setq tab-line-format "")))

#+end_src

**** Minor mode: org-hide-emphasis-mode

#+begin_src emacs-lisp

(define-minor-mode global-org-hide-emphasis-mode
  "Mode for hiding org emphasis markers."
  :global t
  (if global-org-hide-emphasis-mode
      (set-variable 'org-hide-emphasis-markers t)
    (set-variable 'org-hide-emphasis-markers nil)))

(global-org-hide-emphasis-mode 1)

#+end_src

** Keybindings
*** Change keybindings scheme
**** Information

Wakib changes emacs keybindings to be more modern and ergonomic.
This package should be near the top of the this file's features list, so there isn't any error when assigning keybindings to the wakib keymap.

**** History

Here's my adventure with emacs and keybindings:
I grew up with Sublime Text, Atom and VSCode and these all share a (mostly) common set of keybinds.
These are the keybinds I'm interested in using.
I tried standard Emacs keybinds for a short amount of time and I wasn't impressed at all.

Here's my history with trying to use "standard" keybinds packages in emacs:

- ergoemacs-mode
	At first I tried using ergoemacs-mode, but that created a lot of conflicts when my config grew in size as I added more functionality.
	I also had issues with reloading my config file.

- cua-mode
	Then I tried using cua-mode, but it wasn't "standard" enough to my liking.
	The way 'C-x' works in particular was a problem, since I would like to cut a whole line by default when I press C-x and there is no active region selected.

- manual bindings in config
	The next attempt was to bind every key manually in my emacs config file.
	This gave me a lot of control and knowledge over what exactly was happening in terms of keybinds, which I liked.
	It was almost perfect, but not quite there yet.
	I was able to set up all the bindings that are prefixed by Control and I was also able to bind C-x, C-h and C-g to '<menu> x', '<menu> h' and '<menu> g', respectively.
	The problem is that Emacs makes rebinding C-c quite difficult.

- wakib-keys
	I found out a package that was able to deal with the C-c rebind issue, and decided to just use it instead of dealing with all the trouble of rebinding C-c myself.
	Since wakib-keys override the global keymap binds, this involved transferring some of my keybinds to the wakib keymap (wakib-keys-overriding-map).
	It also adds some new keybindings for things that I didn't originally want, but that I think might be useful.
	Finally, I was able to achieve the behavior I wanted

**** Package: wakib-keys

#+begin_src emacs-lisp

(use-package wakib-keys
  :init
  (wakib-keys 1)
  :hook
  (after-change-major-mode . wakib-update-major-mode-map)
  (menu-bar-update . wakib-update-minor-mode-maps))

#+end_src

*** Global Keybindings
**** Information

Here are keybinds that apply globally and don't depend on any package.
Any keybinds that use functions from some package are defined in that package's section.

Some of these are slight alterations to wakib, such as modifying the functions of the keybinds.
Others add convenient things like zoom, reload, fullscreen, etc.

**** Keybinding definition

#+begin_src emacs-lisp

;; reload emacs config file
(bind-key "<C-f5>" 'my/reload-init-file wakib-keys-overriding-map)

;; reload current file
(bind-key "<f5>" 'reload-buffer wakib-keys-overriding-map)

;; make 'C-SPC' select in a rectangle instead of the normal selection
;; (bind-key "C-SPC" 'rectangle-mark-mode wakib-keys-overriding-map)

;; alternative way to quit emacs besides C-x C-c
(bind-key "C-q" 'my/kill-emacs wakib-keys-overriding-map)

;; add a fullscreen toggle
(bind-key "<f11>" 'my/toggle-fullscreen wakib-keys-overriding-map)

(bind-key "<f12>" 'toggle-menu-bar wakib-keys-overriding-map)

(bind-key "C--" 'text-scale-decrease wakib-keys-overriding-map)
(bind-key "C-=" 'text-scale-increase wakib-keys-overriding-map)

(bind-key "<escape>" 'keyboard-escape-quit wakib-keys-overriding-map)

(bind-key "C-<left>" 'backward-word wakib-keys-overriding-map)
(bind-key "C-<right>" 'forward-word wakib-keys-overriding-map)

(bind-key "M-o" nil wakib-keys-overriding-map) ;; the default bind interferes with ivy (show options command)

(bind-key "<backspace>" 'backward-delete-char-untabify)

(bind-key "C-<delete>" 'my/delete-word-no-clipboard wakib-keys-overriding-map)
(bind-key "C-<backspace>" 'my/backward-delete-word-no-clipboard wakib-keys-overriding-map)

(bind-key "<home>" 'my/smarter-move-beginning-of-line wakib-keys-overriding-map)

;; navigate through buffer history
(bind-key "<C-tab>" 'switch-to-prev-buffer wakib-keys-overriding-map)
(bind-key "<C-iso-lefttab>" 'switch-to-next-buffer wakib-keys-overriding-map)  ; equivalent to C-S-tab


(bind-key "C-l" 'recenter-top-bottom wakib-keys-overriding-map)
;; (bind-key "C-l" 'my/select-current-line wakib-keys-overriding-map)


(bind-key "M-s" 'set-mark-command wakib-keys-overriding-map)


(bind-key "C-s" 'save-buffer wakib-keys-overriding-map)


;; (bind-key "M-," 'backward-sexp wakib-keys-overriding-map)
;; (bind-key "M-." 'forward-sexp wakib-keys-overriding-map)
;; (bind-key "M-;" 'my/backward-sexp-with-shift-select wakib-keys-overriding-map)
;; (bind-key "M-:" 'my/forward-sexp-with-shift-select wakib-keys-overriding-map)


(bind-key "C-M-<left>" 'backward-sexp wakib-keys-overriding-map)
(bind-key "C-M-S-<left>" 'my/backward-sexp-with-shift-select wakib-keys-overriding-map)

(bind-key "C-M-<right>" 'forward-sexp wakib-keys-overriding-map)
(bind-key "C-M-S-<right>" 'my/forward-sexp-with-shift-select wakib-keys-overriding-map)


(bind-key "C-M-<up>" 'backward-up-list wakib-keys-overriding-map)
(bind-key "C-M-<down>" 'down-list wakib-keys-overriding-map)


(bind-key "C-t" 'counsel-imenu wakib-keys-overriding-map)


(bind-key "C-<up>" 'backward-paragraph wakib-keys-overriding-map)
(bind-key "C-<down>" 'forward-paragraph wakib-keys-overriding-map)


(bind-key "M-m" 'avy-goto-char wakib-keys-overriding-map)


(bind-key "C-S-r" 'replace-regexp wakib-keys-overriding-map)


;;     on Linux, the menu/apps key syntax is <menu>
;;     on Windows, the menu/apps key syntax is <apps>
;;     make the syntax equal
(define-key key-translation-map (kbd "<apps>") (kbd "<menu>"))


;; can't use this because it would interfere with ivy
;;(bind-key "<backtab>" 'untab-region)
;;(bind-key "<tab>" 'tab-region)

#+end_src

**** Notes and basic usage

*Navigating parenthesis*

A balanced expression can be a parenthetical group, a number, a word or a symbol. The precise definition of a balanced expression may depend on the current mode. Here is how to move from a balanced expression to another:

C-M-n     forward-list   Move forward over a parenthetical group
C-M-p     backward-list  Move backward over a parenthetical group
C-M-f     forward-sexp   Move forward over a balanced expression
C-M-b     backward-sexp  Move backward over a balanced expression
C-M-k     kill-sexp      Kill balanced expression forward


Useful resources:
[[https://shortcutworld.com/VSCode/win/Visual-Studio-Code_Shortcuts][VSCode shortcuts]]
[[https://developer.android.com/studio/intro/keyboard-shortcuts][Android Studio shortcuts]]

** Defaults

Configure stuff that already comes with emacs. No packages are installed in this section.

*** General Preferences

Some nice-to have things and general settings.

#+begin_src emacs-lisp

(setq load-prefer-newer              t
      custom-file                    (expand-file-name "etc/custom.el" user-emacs-directory)  ;; Put Customize blocks in a separate file
      inhibit-startup-screen         t                      ;; disable default startup screen
      uniquify-buffer-name-style     'forward               ;; for files with the same name, include part of directory name at the beginning of the buffer name
      shift-select-mode              t                      ;; allow marks to be set when shift arrow-ing
      focus-follows-mouse            t                      ;; allow using mouse to switch between windows
      browse-url-browser-function    'browse-url-generic    ;; links and html files should be opened in a browser, instead of emacs
      browse-url-generic-program     "xdg-open"
      ring-bell-function             'ignore                ;; disable bell
      blink-cursor-interval          1                      ;; change cursor blink speed. default is 0.5
      require-final-newline          t                      ;; On save, automatically add final newline
      vc-follow-symlinks             t)                     ;; don't ask for confirmation when opening symlinked file

;; this hook applies to every mode, so its the same as applying it globally
(add-hook 'after-change-major-mode-hook #'my/modify-word-definitions)

;; Only require to type 'y' or 'n' instead of 'yes' or 'no' when prompted
(fset 'yes-or-no-p 'y-or-n-p)

;; Everything utf-8
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-buffer-file-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)

;; load file with 'Customize' settings
(when (file-exists-p custom-file)
  (load custom-file))

;; On save, automatically remove trailling whitespace
(add-hook 'before-save-hook 'delete-trailing-whitespace)

;; auto refresh dired when file changes
(add-hook 'dired-mode-hook 'auto-revert-mode)

;; automatically reload files from disk when changed externally
(global-auto-revert-mode 1)

;; dont ask for confirmation for refreshing PDF buffers
(setq revert-without-query '(".pdf"))

;; replace the active region just by typing text and delete the selected text by hitting the Backspace key
(delete-selection-mode 1)

;; highlight matching parentheses
(show-paren-mode 1)

;; automatically add a pair to braces and quotes
(electric-pair-mode 1)
;; (setq electric-pair-skip-self t)
(setq electric-pair-preserve-balance t)
(setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
;; (setq electric-pair-inhibit-predicate 'ignore)

;; switch default cursor type to a thin bar
(setq-default cursor-type 'bar)
(set-cursor-color "#ffffff")

;; new buffers are opened in org-mode by default
(setq-default major-mode 'org-mode)

;; default value is (middle top bottom)
(setq recenter-positions '(top bottom middle))

;; change sorting of folders in dired (these are ls flags)
(setq dired-listing-switches "-laGh1v --group-directories-first")

#+end_src

*** Indentation

#+begin_src emacs-lisp

;; set default tab width globally
(setq-default tab-width 2)

;; use spaces for indentation by default
(setq-default indent-tabs-mode nil)

;; make tabs appear visible as a “|” (pipe) character
(global-whitespace-mode)                                ; make all whitespace visible
(setq whitespace-style '(face tabs tab-mark trailing))  ; only show tabs and trailing whitespace
(custom-set-faces
 ;; '(whitespace-tab         ((t (:foreground "#636363"))))   ; set tab character color
 '(whitespace-tab         ((t (:foreground "#290929093b7a"))))   ; set tab character color
 '(whitespace-trailing    ((t (:underline (:style wave :color "yellow2")))))
 )

;; set tab character
;; U+00BB -> double right arrow
;; U+23D0 -> vertical line
;; U+007C -> pipe

;; copy character from highlight-indent-guides
;; ?\x2502 / 9474

(setq whitespace-display-mappings
      ;; '((tab-mark 9 [124 9] [92 9]))
      '((tab-mark ?\t [?\x2502 ?\t])))

(setq backward-delete-char-untabify-method 'untabify)

#+end_src

*** Tabs

=Tabs= as in the ones found at the top of a browser window.

#+begin_src emacs-lisp

;; disable "close" (x) button for each tab
(setq tab-line-close-button-show nil)

;; disable "new tab" (+) button at the right end of the tab-line
(setq tab-line-new-button-show nil)

;; redefine function for tab names
(defun my/tab-line-tab-name-buffer (buffer &optional _buffers)
  "Define format of tab names."
  (format "  %s  " (buffer-name buffer)))

(setq tab-line-tab-name-function #'my/tab-line-tab-name-buffer)

(setq tab-line-exclude-modes '(dashboard-mode
                               magit-status-mode
                               bufler-list-mode
                               org-agenda-mode
                               term-mode
                               dired-sidebar-mode))

#+end_src

*** Scrolling

#+begin_src emacs-lisp

;; try to improve scrolling in emacs. still not ideal though
(setq scroll-conservatively              101       ;; this value shoul not be higher than 100, or else swiper has issues (text behind modeline)
      mouse-wheel-scroll-amount          '(1)
      scroll-margin                      3
      scroll-preserve-screen-position    t
      mouse-wheel-progressive-speed      nil
      fast-but-imprecise-scrolling       t)

;;(pixel-scroll-mode)   ; this makes it a bit laggy

#+end_src

*** Fringe, Margin and line numbers

#+begin_src emacs-lisp

;; only show an indicator on the right fringe and not the left fringe
(setq-default visual-line-fringe-indicators '(nil right-curly-arrow))

(setq-default fringe-indicator-alist '(
  (truncation left-arrow right-arrow)
  (continuation nil right-curly-arrow) ;; left-curly-arrow (only line changed)
  (overlay-arrow . right-triangle)
  (up . up-arrow)
  (down . down-arrow)
  (top top-left-angle top-right-angle)
  (bottom bottom-left-angle bottom-right-angle top-right-angle top-left-angle)
  (top-bottom left-bracket right-bracket top-right-angle top-left-angle)
  (empty-line . empty-line)
  (unknown . question-mark)))

;; make numbers column width a little bigger so it never changes size and moves the buffer. (refering to line numbers)
;; with a value of 3 digits, the buffer only moves when the line number is 1000 or hifher
(setq-default display-line-numbers-width 4)

;; dont show line numbers for these modes
(add-hook 'doc-view-mode-hook (lambda () (display-line-numbers-mode -1)))
(add-hook 'pdf-view-mode-hook (lambda () (display-line-numbers-mode -1)))
(add-hook 'eshell-mode-hook (lambda () (display-line-numbers-mode -1)))
(add-hook 'ediff-mode-hook (lambda () (display-line-numbers-mode -1)))

;; set size in pixels of left and right fringes (default is 8)
(fringe-mode '(4 . 8))
;; (set-fringe-mode '(0 . 0))

#+end_src

*** Backup, Autosave and Lockfiles

#+begin_src emacs-lisp

(setq auto-save-file-name-transforms    `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))    ;; change auto-save location
      auto-save-default                 t           ;; put auto-save files in designated folder
      backup-inhibited                  t           ;; disable file backup
      create-lockfiles                  nil)        ;; stop emacs from creating temoporary symbolic link file named “#something”

#+end_src

*** Desktop session

#+begin_src emacs-lisp

(setq desktop-save               t             ;; always save on exit and never ask before saving
      desktop-restore-eager      nil           ;; number of buffers to restore immediatly
      desktop-dirname            (no-littering-expand-var-file-name "desktop/")
      desktop-base-file-name     "emacs.desktop"
      desktop-save-mode          nil)

#+end_src

*** Directory local variables                                    :notangle:

It is possible to create directory-local settings without using a .dir-locals.el file or modifying the original file.
I prefer this approach because it is centralized and has less clutter.

This can be used to assign values to certain variables only to certain directories.
It is also possible set functions to evaluate at startup, for those directories.

For more information about syntax, check the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html][documentation]].

#+begin_src emacs-lisp

;; Here, we make the config file show 2 heading levels at startup, to make navigation easier.
(dir-locals-set-class-variables 'dir-local--emacs-config
    '((org-mode . ((eval org-content 2)))))

(dir-locals-set-directory-class
    "~/.emacs.d/" 'dir-local--emacs-config)

#+end_src

*** Searching

Note: this is a package that is installed by default, so that's why it's in this section.

#+begin_src emacs-lisp

(use-package isearch
  :straight nil
  :custom
  (search-whitespace-regexp ".*?")
  (isearch-lax-whitespace t)
  (isearch-regexp-lax-whitespace nil)
  :bind
  (:map isearch-mode-map
        ("j" . isearch-repeat-backward)
        ("k" . isearch-repeat-forward)))

#+end_src

*** Window Splits

Patch =split-window-sensibly= function so that it prefers vertical splits over horizontal ones.

=split-window-horizontally= and =split-window-vertically= have been changed to switch to the new window after a split.
=split-window-sensibly= works as normal, but its behaviour is controlled by the =shackle= package.

#+begin_src emacs-lisp

;; define values for split-sensibly
;; Note: the thresholds need to be twice as big as the smallest window allowed, because the new windows each use half of former window size.
(setq split-width-threshold 100
      split-height-threshold 40)
;; 160/80

(with-eval-after-load "window"
  (defcustom split-window-below nil
    "If non-nil, vertical splits produce new windows below."
    :group 'windows
    :type 'boolean)

  (defcustom split-window-right nil
    "If non-nil, horizontal splits produce new windows to the right."
    :group 'windows
    :type 'boolean)

  (fmakunbound #'split-window-sensibly)

  (defun split-window-sensibly (&optional window)
    (setq window (or window (selected-window)))
    (or (and (window-splittable-p window t)
             ;; Split window horizontally.
             (split-window window nil (if split-window-right 'left  'right)))
        (and (window-splittable-p window)
             ;; Split window vertically.
             (split-window window nil (if split-window-below 'above 'below)))
        (and (eq window (frame-root-window (window-frame window)))
             (not (window-minibuffer-p window))
             ;; If WINDOW is the only window on its frame and is not the
             ;; minibuffer window, try to split it horizontally disregarding the
             ;; value of `split-width-threshold'.
             (let ((split-width-threshold 0))
               (when (window-splittable-p window t)
                 (split-window window nil (if split-window-right
                                                             'left
                                                           'right))))))))

(defun my/split-window-horizontally-and-follow ()
  (interactive)
  "Like `split-window-horizontally’, but focuses the newly created window."
  (select-window (split-window-horizontally)))

(defun my/split-window-vertically-and-follow ()
  (interactive)
  "Like `split-window-vertically’, but focuses the newly created window."
  (select-window (split-window-vertically)))

#+end_src

** External Features

Add more features by installing emacs packages.

*** Icon integration
**** Package: all-the-icons

Allow Emacs to use icons in various UI elements.

Important reminder: The first time this package is installed, you need to run 'all-the-icons-install-fonts' to install fonts.

#+begin_src emacs-lisp

(use-package all-the-icons
  :config
  (setq all-the-icons-color-icons t))

#+end_src

*** Project Management
**** Package: projectile

#+begin_src emacs-lisp

(use-package projectile
  :config
  (setq projectile-completion-system 'ivy)
  ;; (setq projectile-indexing-method 'hybrid)
  (projectile-mode 1)
  :pretty-hydra
  ((:title "Project" :color teal :quit-key "q")
   ("Current project"
    (("f" fzf-git-files "find file")
     ("r" projectile-recentf "recent file")
     ("b" projectile-switch-to-buffer "switch to open buffer"))
    "Manage Projects"
    (("p" counsel-projectile-switch-project "switch to project")
     ("a" projectile-add-known-project "add a new project")
     ("d" projectile-remove-known-project "delete known project"))
    )))

#+end_src

**** Notes and basic usage

To use a non-repository folder as a project, create a blank '.projectile' file in the folder to mark the project root.
See [[https://docs.projectile.mx/projectile/projects.html#ignoring-file]] for what to write in this file.

Quick version of what to write in .projectile:
'-' to ignore
'+' to keep and ignore everything else
'!' to override .gitignore

*** Workspaces
**** Information

Also called Layouts, Perspectives, Sessions.

What I want for this feature is to be able to save and load lists of files using workspaces.
Workspaces should be able to be composed of multiple items. Each item can be a project, normal folder or normal file.
I use the name 'workspaces' in this section, but it's interchangeable with other names for this type of thing in emacs.

Restoring the window sizes, positions and layouts is not so important for me.

Specific features I want:
  - when in a workspace, show list of open buffers, restricted to that workspace
  - cycle between all the buffers in the current workspace
  - save, load and switch workspaces
  - when switching workspaces, automatically prompt for file to open or go to last visited file
  - save or load a single workspace. each workspace has it's own file or section. it shouldn't be all or nothing
  - give workspaces a custom name
  - integration with dashboard package (needs a way of getting list of existing workspaces)
  - show current workspace in the modeline

Another idea I've had is the following:
  - whenever you enter a projectile project, the sidebar and tab-bar automatically show information from only that project.
  - for everthing else, the sidebar shows the current file's parent directory and the tab-bar shows all the non-project files.

Currently using: bufler with optional bufler-tabs-mode

**** Package: persp-mode                                        :notangle:

#+begin_src emacs-lisp

(use-package persp-mode
  :config
  (setq persp-auto-resume-time                         -1
        persp-auto-save-opt                            0
        persp-auto-save-num-of-backups                 0
        persp-set-last-persp-for-new-frames            nil
        persp-reset-windows-on-nil-window-conf         t
        persp-autokill-buffer-on-remove                t
        persp-add-buffer-on-after-change-major-mode    t
        persp-kill-foreign-buffer-behaviour            'kill)
  (persp-mode 1))


(persp-load-state-from-file (expand-file-name "var/persp-mode/persp-auto-save" user-emacs-directory))

#+end_src


#+begin_src emacs-lisp

(use-package perspective
  :config
  (persp-mode))

(persp-turn-off-modestring)

(setq persp-state-default-file (expand-file-name "var/persp-mode/persp-auto-save" user-emacs-directory))
;; (add-hook 'after-init-hook (persp-state-load persp-state-default-file))

(bind-key "C-b" 'projectile-switch-to-buffer wakib-keys-overriding-map)

(add-to-list 'persp-filter-save-buffers-functions
             (lambda (b) (string-prefix-p "todo" (buffer-name b))))

#+end_src

**** Package: bufler

When dealing with the =org-directory= variable, it is important to pay attention to the order in which the org package is loaded.

#+begin_src emacs-lisp

(use-package bufler
  :init
  ;; always switch workspace when switching buffers with bufler
  (setq bufler-workspace-switch-buffer-sets-workspace nil)

  ;; (defun my/bufler-workspace-mode-lighter ()
  ;;   "Return lighter string for mode line."
  ;;   (frame-parameter nil 'bufler-workspace-path-formatted))

  ;; redefine lighter function
  (defun my/bufler-workspace-mode-lighter-shorter ()
    "Return lighter string for mode line.
Only the last element of the path is displayed."
    (frame-parameter nil 'bufler-workspace-path-formatted))

  (defun my/bufler-workspace-mode-lighter-full ()
    "Return full lighter string for mode line help menu."
    (mapconcat 'identity (frame-parameter nil 'bufler-workspace-path) " » "))

  (defun my/bufler-format-path (path)
    "Return PATH formatted as a string."
    (concat (replace-regexp-in-string ".*» " ""
                                      (replace-regexp-in-string "Projectile:" ""
                                                                (bufler-format-path path)))))

  (setq bufler-workspace-format-path-fn 'my/bufler-format-path)

  :config
  (bufler-tabs-mode 1)
  (tab-bar-mode 0)
  (global-tab-line-mode 0)
  ;; show files first and special buffers last
  (setq bufler-reverse t)
  ;; add newline at end of top-level each group
  (setq bufler-list-group-separators '((0 . "\n")))

  ;; try to filter/ignore special buffers

  ;; (defun my/bufler-filter-special-buffers (buffer)
  ;;   "Return non-nil if BUFFER is special.
  ;;   That is, if its name starts with \"*\"."
  ;;   (string-match-p (rx bos (1+ "*") (one-or-more anything) (1+ "*") eos) (buffer-name buffer)))

  ;; (defun my/bufler-filter-special-buffers (buffer)
  ;;   "Return non-nil if BUFFER is special.
  ;;   That is, if its bufler workspace name starts with \"*\"."
  ;;   (let* ((selected-buffer    (get-buffer (buffer-name)))
  ;;          (selected-workspace (bufler-format-path (bufler-buffer-workspace-path selected-buffer))))
  ;;     (string-match-p (rx bos (1+ "*") (one-or-more anything) (1+ "*") eos) selected-workspace)
  ;;     ))

  ;; (setq bufler-filter-fns (list #'bufler-hidden-buffer-p #'my/bufler-filter-special-buffers))

  (defun my/bufler-workspace-set-from-buffer-name (buffer-name)
    "Focus workspace of buffer BUFFER-NAME."
    (let ((selected-buffer (get-buffer buffer-name)))
      (bufler-workspace-frame-set
       (butlast (butlast (bufler-group-tree-leaf-path (bufler-buffers) selected-buffer))))))

  (defun my/bufler-switch-buffer-C-u ()
    "Use `bufler-switch-buffer', but as if C-u was pressed before it."
    (interactive)
    (let ((current-prefix-arg 4)) ;; emulate C-u
      (call-interactively 'bufler-switch-buffer)))

  (setf bufler-groups
        (bufler-defgroups
          (group
           ;; Subgroup collecting all named workspaces.
           (auto-workspace))

          (group
           ;; Subgroup collecting all special buffers (i.e. ones that are not file-backed)
           (group-and "*Special*"
                      (lambda (buffer)
                        (unless (or (funcall (mode-match "Scratch" (rx bos "lisp-interaction")) buffer)
                                    (funcall (name-match "Untitled" (rx bos "untitled")) buffer)
                                    (funcall (auto-file) buffer))
                          "*Special*")))
           (group
            ;; Subgroup collecting these "special special" buffers
            ;; separately for convenience.
            (name-match "Essential"
                        (rx bos "*" (or "Messages" "Warnings" "Backtrace" "dashboard" "Bufler") "*")))

           (group
            (group-not "Non-Essential"
                       ;; match all remaining special buffers
                       ;; none of them will match because they do not have associated files and filenames
                       (filename-match "files" (rx bol (zero-or-more anything))))
            (auto-mode)))

          (group
           (group-or "Agenda and Notes"
                     ;; Subgroup collecting buffers in `org-directory' (or "~/Org" if
                     ;; `org-directory' is not yet defined).
                     (dir (if (bound-and-true-p org-directory)
                              org-directory
                            "~/Cloud/Work - Google Cloud/Org/")))
           (auto-directory))

          (group
           (group-or "All Files"
                     (filename-match "Files" (rx bol (zero-or-more anything)))
                     ;; (mode-match "Dashboard" (rx bos "dashboard"))
                     (mode-match "Scratch" (rx bos "lisp-interaction"))
                     (name-match "Untitled" (rx bos "untitled")))

           (group
            (auto-projectile))

           (group
            (auto-directory))

           ;; (group
           ;;  (dir "~"))
           ;; (group
           ;;  (dir "/"))

           )
          ))

  :bind
  (:map wakib-keys-overriding-map
        ("C-p" . bufler-switch-buffer)
        ("C-<prior>" . tab-line-switch-to-prev-tab)
        ("C-<next>" . tab-line-switch-to-next-tab))

  :hook (;; focus current buffer workspace everytime a file is opened
         ;; (find-file . (lambda () (call-interactively #'bufler-workspace-focus-buffer)))
         (bufler-list-mode . my/set-buffer-large-fringe)
         ;; modify frame name without modfying workspace name. this function definition doesnt work if used in a init or config block
         (emacs-startup . (lambda () (defun bufler-workspace-set-frame-name (path)
                                      "Set current frame's name according to PATH."
                                      (set-frame-name (when path
                                                        (format "Workspace: %s -- Emacs" (funcall bufler-workspace-format-path-fn path)))))))
         ;; focus the workspace of the "scratch" buffer at startup, which is the "All Files" workspace
         (emacs-startup . (lambda () (my/bufler-workspace-set-from-buffer-name "*scratch*")))
         ))

#+end_src

**** Notes and basic usage

*Keybindings*

Default keymap

| Keybind     | Action                                                                 |
|-------------+------------------------------------------------------------------------|
| C-p         | switch to buffer in current workspace                                  |
| C-u C-p     | switch to buffer in any workspace                                      |
| C-u C-u C-p | switch to buffer in any workspace (and also set the frame's workspace) |
| <hydra> b b | show bufler workspace list                                             |

Inside bufler workspace list

| Keybind | Action                   |
|---------+--------------------------|
| ?       | show available keybinds  |
| f       | focus selected workspace |
| q       | close bufler window      |

Note: When you use bufler-switch-buffer, the first result is always the last opened buffer.
So you can use =C-p RET= to quickly return to the previously used buffer.

**** History

Packages I looked at:

- treemacs workspaces:
  + a workspace can only have projects or folders (but it's possible to use bookmarks for files)
  + Can not list all buffers in current workspace
  + can use projectile and bookmarks to cover some functionality

- eyebrowse:
  + does not save files, only layouts
  + works like i3 workspaces
  + the way it works is that you assign a workspace to a certain purpose and only open certain projects in there

- bufler (bufler-workspace-mode):
  + bufler-list is good for managing buffers. works like magit
  + the tab-bar integration is nice
  + does not save files
  + I tried to use desktop-save-mode for saving stuff, but wasnt very happy with it
  + bufler-workspace-mode allows to automatically switch workspaces when switching buffers
  + can use bookmarks to cover some functionality

- projectile + bookmarks:
  + needs a special file in a project directory to give it a custom name
  + it's not ideal for normal non-repo folders

- perspective and persp-mode (shared):
  + doesn't really have a concept of projects, only buffers
  + saves and loads all perspectives at once. on file load, all buffers from all saved perspectives are opened
  + persp-mode is more popular and supported, while perspective is simpler and nicer to configure

- perspective:
  + the list of buffers in current perspective works better than persp-mode

- persp-mode:
  + it's a pain to setup and the documentation is pretty lacking (these are related)
  + cant make it load save file at startup without resuming session
  + the list of buffers in current perspective shows a bunch or useless buffers

*** File Explorer
**** Information

Since I am using Treemacs workspaces I will explain my view on projects and workspaces.

Here is my ideal usage of workspaces/projects:
  - each project has a name that can be easily configured
  - a list of projects appears in the dashboard (with their custom names)
  - you can search all files in a project
  - the project name appears in the modeline
  - all of the previous items should also work with a standard folder (even if it's not a repository)

That last item is very important. It's the reason why I projectile by itself isn't enough.

This is a desired but not required feature:
  - no files are saved on project directory, or as few as possible. everthing should be saved in the '.emacs.d' folder

Taking this into account, projectile is a good start but it doesnt give me everything I want, so I'm also using Treemacs workspaces.

**** Package: dired-sidebar

The sidebar only changes when bufler focuses a new workspace.

#+begin_src emacs-lisp

(use-package dired-sidebar
  :commands (dired-sidebar-toggle-sidebar)
  :init
  (add-hook 'dired-sidebar-mode-hook
             (lambda ()
               (unless (file-remote-p default-directory)
                 (auto-revert-mode))))

  ;; (setq dired-sidebar-mode-line-format '("test" major-mode " "))
  ;; (setq dired-sidebar-mode-line-format '("%e" mode-line-front-space major-mode " " mode-line-end-spaces))
  ;; ("%e" mode-line-front-space mode-line-buffer-identification " " mode-line-end-spaces)

  :config
  (setq dired-sidebar-theme                   'ascii
        dired-sidebar-one-instance-p          t
        dired-sidebar-no-delete-other-windows t
        dired-sidebar-width                   30)

  (defun my/dired-sidebar-focus-bufler (a)
    "Make dired-sidebar focus current bufler workspace."
    (with-current-buffer (car (bufler-workspace-buffers))
      (let ((root (dired-sidebar-get-dir-to-show)))
        (dired-sidebar-switch-to-dir root))))

  :hook
  (dired-sidebar-mode . (lambda () (display-line-numbers-mode -1)))
  (dired-sidebar-mode . hide-mode-line-mode)
  ;; (dired-sidebar-mode . dired-sidebar-set-mode-line)
  (bufler-workspace-set . my/dired-sidebar-focus-bufler)
  (bufler-workspace-set . bufler-workspace-set-frame-name))

#+end_src

**** Package: treemacs                                          :notangle:

#+begin_src emacs-lisp

(use-package treemacs
  :config
  (treemacs-follow-mode t)
  (treemacs-filewatch-mode t)



  ;; (defun treemacs--follow-after-eyebrowse-switch ()
  ;;   (when treemacs-follow-mode
  ;;     (--when-let (treemacs-get-local-window)
  ;;       (with-selected-window it
  ;;         (treemacs--follow-after-buffer-list-update)
  ;;         (hl-line-highlight)))))

  ;; (add-hook 'bufler-workspace-set-hook #'treemacs--follow-after-eyebrowse-switch)



  ;; (add-hook 'bufler-list-mode-hook 'treemacs-display-current-project-exclusively)


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; (add-hook 'treemacs-select-hook 'treemacs-add-and-display-current-project)     ;;
  ;; (add-hook 'treemacs-select-hook 'treemacs-display-current-project-exclusively) ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



  ;; (defun my/change-cursor (&rest args)
  ;;   "Change cursor according to evil states in CUI."
  ;;   (unless (display-graphic-p)
  ;;     (call-interactively 'treemacs-display-current-project-exclusively)
  ;;     ))

  ;; (add-hook 'window-selection-change-functions 'my/change-cursor)
  ;; (add-hook 'window-buffer-change-functions 'my/change-cursor)
  ;; (add-hook 'window-state-change-hook 'my/change-cursor)
  ;; (add-hook 'buffer-list-update-hook 'my/change-cursor)




  ;; (defun change-cursor (&rest args)
  ;;   "Change cursor according to evil states in CUI."
  ;;   (unless (display-graphic-p)
  ;;     (send-string-to-terminal ;;           bar        block
  ;;      (if evil-insert-state-minor-mode "\033[6 q" "\033[2 q"))))

  ;; (dolist (hook '(window-selection-change-functions evil-insert-state-entry-hook evil-normal-state-entry-hook))
  ;;   (add-hook hook 'change-cursor))


  :hook (treemacs-mode . (lambda () (display-line-numbers-mode -1)))  ;; dont show line numbers in the sidebar
  :bind
  (:map treemacs-mode-map
        ("<mouse-1>" . treemacs-single-click-expand-action))  ;; single mouse click to open files and folders
  )


;; (defun my-treemacs-switch-workspace (ws)
;;   (setf (treemacs-current-workspace) (treemacs--select-workspace-by-name ws))
;;   (treemacs--invalidate-buffer-project-cache)
;;   (treemacs--rerender-after-workspace-change)
;;   (treemacs-select-window)
;;   (run-hooks 'treemacs-switch-workspace-hook)
;;   )

;; (defun dashboard-insert-treemacs-workspaces (list-size)
;;   (treemacs--maybe-load-workspaces)
;;   (dashboard-insert-section
;;    "Workspaces:"
;;    (dashboard-subseq (mapcar 'treemacs-workspace->name (treemacs-workspaces)) 0 list-size)
;;    list-size
;;    "w"
;;    `(lambda (&rest ignore) (my-treemacs-switch-workspace ,el))
;;    el)

#+end_src

**** Package: treemacs-projectile                               :notangle:

#+begin_src emacs-lisp

(use-package treemacs-projectile
  :after treemacs projectile)

#+end_src

**** Package: treemacs-magit                                    :notangle:

#+begin_src emacs-lisp

(use-package treemacs-magit
  :after treemacs magit)

#+end_src

*** Dashboard
**** Package: hide-mode-line

#+begin_src emacs-lisp

;; hide the modeline in the dashboard buffer
(use-package hide-mode-line)

#+end_src

**** Package: page-break-lines

#+begin_src emacs-lisp

(use-package page-break-lines
  :config
  ;; some fonts make the line break too long or too short.
  ;; so we just use something that is common and we know that works
  (custom-set-faces
   '(page-break-lines ((t (:family "Noto Sans Mono")))))

  (global-page-break-lines-mode 1))

#+end_src

**** Package: dashboard

#+begin_src emacs-lisp

(use-package dashboard
  :defer nil
  :after hide-mode-line page-break-lines
  :config
  (dashboard-setup-startup-hook)

  (defun dashboard-insert-persp-mode (list-size)
    (dashboard-insert-section
     "Perspectives:"
     bufler-workspace-name
     list-size
     "p"
     `(lambda (&rest ignore) (persp-switch ,el))
     el))

  (defun my/open-dashboard ()
    (interactive)
    (switch-to-buffer (get-buffer "*dashboard*")))

  (add-to-list 'dashboard-item-generators '(perspectives . dashboard-insert-persp-mode))

  ;;  (add-to-list 'dashboard-heading-icons '(treemacs-workspaces . "book"))
  ;;  (dashboard-modify-heading-icons '((treemacs-workspaces . "book")))

  (setq dashboard-items                '((projects  . 5)
                                         (bookmarks . 5)
                                         (recents   . 5))
        dashboard-center-content       t
        dashboard-set-heading-icons    t
        dashboard-set-init-info        t
        dashboard-set-footer           nil
        dashboard-set-navigator        t
        dashboard-startup-banner       (expand-file-name "base/resources/Emacs-logo.svg" user-emacs-directory)
        dashboard-banner-logo-title    (format "GNU Emacs version %d.%d" emacs-major-version emacs-minor-version)
        dashboard-init-info            (format "%d packages loaded with straight. finished in %s"
                                               (length (hash-table-keys straight--success-cache)) (emacs-init-time))
        dashboard-navigator-buttons    `(((,(all-the-icons-octicon "dashboard" :height 1.1 :v-adjust 0.0)
                                           "Config file"
                                           "Open private configuration file"
                                           (lambda (&rest _) (my/open-init-file)))
                                          (,(all-the-icons-octicon "gear" :height 1.1 :v-adjust 0.0)
                                           "Restore session"
                                           "Add buffers from last saved session to current session"
                                           (lambda (&rest _) (my/desktop-enable)))
                                          (,(all-the-icons-octicon "globe" :height 1.1 :v-adjust 0.0)
                                           "Browse Packages"
                                           "Search for packages on MELPA"
                                           (lambda (&rest _) (browse-url "https://melpa.org")))
                                          )))

  :hook ((dashboard-mode . hide-mode-line-mode)
         (dashboard-mode . my/set-buffer-dashboard-fringe)))

#+end_src

*** Modeline
**** Package: doom-modeline

#+begin_src emacs-lisp

(use-package doom-modeline
  :init
  (setq doom-modeline-height                      24
        doom-modeline-major-mode-icon             nil
        doom-modeline-major-mode-color-icon       nil
        doom-modeline-indent-info                 t
        doom-modeline-buffer-state-icon           t
        doom-modeline-buffer-modification-icon    t
        doom-modeline-buffer-file-name-style      'truncate-upto-project
        doom-modeline-window-width-limit          120)

  :config

  ;;
  ;; Segment - Workspaces
  ;;

  (doom-modeline-def-segment my/bufler-workspace
    "Display current bufler workspace name"
    (if (and (boundp 'bufler-workspace-tabs-mode) bufler-workspace-tabs-mode)
        (let ((active (doom-modeline--active)))
          (when-let (text
                     (propertize (format " %s" (my/bufler-workspace-mode-lighter-shorter))
                                 'face '(:foreground "gray60")
                                 'mouse-face 'mode-line-highlight
                                 'help-echo (format "Full workspace name: %s\nmouse-1: Choose workspace"
                                                    (my/bufler-workspace-mode-lighter-full))
                                 'local-map (let ((map (make-sparse-keymap)))
                                              (define-key map [mode-line mouse-1] 'bufler-workspace-frame-set)
                                              map)
                                 ))
            (if active
                text
              (propertize text 'face 'mode-line-inactive))))
      ""))

  ;;
  ;; Segment - Buffer Position
  ;;

  ;; Provides information to the buffer position segment
  (setq-default mode-line-position
                '((line-number-mode
                   (column-number-mode
                    (column-number-indicator-zero-based "%06l L,%03c C" " %l:%C")
                    " %l")
                   (column-number-mode (column-number-indicator-zero-based " :%c" " :%C")))
                  (mode-line-percent-position ("  " mode-line-percent-position))
                  (:eval (when (or line-number-mode mode-line-percent-position column-number-mode) "  "))))

  (doom-modeline-def-segment my/buffer-position
    (concat
     (propertize (replace-regexp-in-string "%" "%%" (format-mode-line '("" mode-line-position)))
                 'mouse-face 'mode-line-highlight
                 'help-echo (format "Current Line, Column and Buffer percentage"))))

  ;;
  ;; Segment - VCS
  ;;

  (doom-modeline-def-segment my/vcs
    "Displays the current branch, colored based on its state."
    (let ((active (doom-modeline--active)))
      (when-let ((icon doom-modeline--vcs-icon)
                 (text git-ml))   ;; doom-modeline--vcs-text
        (concat
         (doom-modeline-spc)
         (doom-modeline-spc)
         (propertize
          (if active
              icon
            (doom-modeline-propertize-icon icon 'mode-line-inactive))
          'mouse-face 'mode-line-highlight
          'help-echo (get-text-property 1 'help-echo vc-mode)
          'local-map (get-text-property 1 'local-map vc-mode))
         (propertize
          (if active
              text
            (propertize text 'face 'mode-line-inactive))
          'mouse-face 'mode-line-highlight
          'help-echo (concat (get-text-property 1 'help-echo vc-mode)
                             "\nIcons:"
                             "\n  ! = Unstaged"
                             "\n  + = Staged"
                             "\n  ? = Untracked"
                             "\n  ~ = Unmerged"
                             "\n  ↑= Commits Ahead"
                             "\n  ↓= Commits Behind")
          'local-map (get-text-property 1 'local-map vc-mode))))))

  ;;
  ;; Segment - Buffer Name
  ;;

  ;; when the buffer is modified only show icon with 'modified' font, not the file name
  (defsubst doom-modeline--buffer-name-custom ()
    "The current buffer name."
    ;; Only display the buffer name if the window is small, but doesn't need to
    ;; respect file-name style.
    (if (and (not (eq doom-modeline-buffer-file-name-style 'file-name))
             doom-modeline--limited-width-p)
        (propertize "%b"
                    'face (cond ((doom-modeline--active) 'doom-modeline-buffer-file)
                                (t 'mode-line-inactive))
                    'mouse-face 'mode-line-highlight
                    'help-echo "Buffer name
mouse-1: Previous buffer
mouse-3: Next buffer"
                    'local-map mode-line-buffer-identification-keymap)
      (when-let ((name (or doom-modeline--buffer-file-name
                           (doom-modeline-update-buffer-file-name))))
        (if (doom-modeline--active)
            name
          (propertize name 'face 'mode-line-inactive)))))

  ;; (defsubst doom-modeline--buffer-name-custom ()
  ;;   "The current buffer name."
  ;;   (if doom-modeline--limited-width-p
  ;;       (s-truncate 10 (format "%s" (propertize "%b")))
  ;;     "ab"))

  ;; (defvar my/buffer-name-max-char 10
  ;;   "The maximal length of the buffer name in modeline.")
  ;; (setq my/buffer-name-max-char 10)
  ;; ;; (s-truncate)

  (doom-modeline-def-segment my/buffer-info
    "Combined information about the current buffer, including the current working
directory, the file name, and its state (modified, read-only or non-existent)."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-state-icon)
     (doom-modeline--buffer-mode-icon)
     (doom-modeline--buffer-name-custom)))

  ;;
  ;; Segment - Buffer line endings
  ;;

  (doom-modeline-def-segment my/buffer-eol
    "Displays the eol and the encoding style of the buffer the same way Atom does."
    (when doom-modeline-buffer-encoding
      (let ((face (if (doom-modeline--active) 'mode-line 'mode-line-inactive))
            (mouse-face 'mode-line-highlight))
        (concat
         (doom-modeline-spc)
         ;; eol type
         (let ((eol (coding-system-eol-type buffer-file-coding-system)))
           (propertize
            (pcase eol
              (0 "LF  ")
              (1 "CRLF  ")
              (2 "CR  ")
              (_ ""))
            'face face
            'mouse-face mouse-face
            'help-echo (format "End-of-line style: %s\nmouse-1: Select from popular options\nmouse-3: Cycle"
                               (pcase eol
                                 (0 "Unix-style LF")
                                 (1 "DOS-style CRLF")
                                 (2 "Mac-style CR")
                                 (_ "Undecided")))
            'local-map (let ((map (make-sparse-keymap)))
                         (define-key map [mode-line mouse-1] 'my/set-buffer-line-ending-style)
                         (define-key map [mode-line mouse-3] 'mode-line-change-eol)
                         map)))
         ))))

  ;;
  ;; Segment - Buffer encoding
  ;;

  (doom-modeline-def-segment my/buffer-encoding
    "Displays the eol and the encoding style of the buffer the same way Atom does."
    (when doom-modeline-buffer-encoding
      (let ((face (if (doom-modeline--active) 'mode-line 'mode-line-inactive))
            (mouse-face 'mode-line-highlight))
        (concat
         ;; coding system
         (propertize
          (let ((sys (coding-system-plist buffer-file-coding-system)))
            (cond ((memq (plist-get sys :category)
                         '(coding-category-undecided coding-category-utf-8))
                   "UTF-8 ")
                  (t (upcase (symbol-name (plist-get sys :name))))))
          'face face
          'mouse-face mouse-face
          'help-echo 'mode-line-mule-info-help-echo
          'local-map mode-line-coding-system-map)
         (doom-modeline-spc)
         ))))

  ;;
  ;; Segment - Selection
  ;;

  ;; this is modified to not appear when the number of selected characters is equal to 0
  (doom-modeline-def-segment selection-info
    "Information about the current selection, such as how many characters and
lines are selected, or the NxM dimensions of a block selection."
    (when (and (or mark-active (and (bound-and-true-p evil-local-mode)
                                    (eq evil-state 'visual)))
               (doom-modeline--active))
      (cl-destructuring-bind (beg . end)
          (if (and (bound-and-true-p evil-local-mode) (eq evil-state 'visual))
              (cons evil-visual-beginning evil-visual-end)
            (cons (region-beginning) (region-end)))


        (when (not (= (- end beg) 0))


          (propertize
           (let ((lines (count-lines beg (min end (point-max)))))
             (concat (doom-modeline-spc)
                     (cond ((or (bound-and-true-p rectangle-mark-mode)
                                (and (bound-and-true-p evil-visual-selection)
                                     (eq 'block evil-visual-selection)))
                            (let ((cols (abs (- (doom-modeline-column end)
                                                (doom-modeline-column beg)))))
                              (format "%dx%dB" lines cols)))
                           ((and (bound-and-true-p evil-visual-selection)
                                 (eq evil-visual-selection 'line))
                            (format "%dL" lines))
                           ((> lines 1)
                            (format "%dC %dL" (- end beg) lines))
                           ((format "%dC" (- end beg))))
                     (when doom-modeline-enable-word-count
                       (format " %dW" (count-words beg end)))
                     (doom-modeline-spc)))
           'face 'doom-modeline-highlight)))))

  ;;
  ;; Segment - Spellcheck
  ;;

  (doom-modeline-def-segment my/spellcheck
    "Display current dictionary language"
    (if flyspell-mode
        (let ((active (doom-modeline--active)))
          (when-let (text
                     (propertize (format " %s " ispell-current-dictionary)  ;
                                 'face '(:foreground "gray60")
                                 'mouse-face 'mode-line-highlight
                                 'help-echo (format "Spellcheck dictionary language: %s\nmouse-1: Change dictionary"
                                                    ispell-current-dictionary)
                                 'local-map (let ((map (make-sparse-keymap)))
                                              (define-key map [mode-line mouse-1] 'ispell-change-dictionary)
                                              map)))
            (if active
                text
              (propertize text 'face 'mode-line-inactive))))
      ""))

  ;;
  ;; Segment - Indentation
  ;;

  (doom-modeline-def-segment my/indent-info
    "Displays the indentation information."
    (when doom-modeline-indent-info
      (let ((do-propertize
             (lambda (mode size)
               (propertize
                (format " %s%d " mode size)
                'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                'mouse-face 'mode-line-highlight
                'help-echo (format "Current indentation type: %s\nCurrent indentation size: %s
mouse-1: Set indentation size
mouse-3: Open indentation menu"
                                   (my/check-indentation-type)
                                   (my/get-buffer-indentation-size))
                'local-map (let ((map (make-sparse-keymap)))
                             (define-key map [mode-line mouse-1] 'my/set-buffer-indentation-size)
                             (define-key map [mode-line mouse-3] 'hydra-indentation/body)
                             map)))))
        (if indent-tabs-mode
            (funcall do-propertize "TAB:" tab-width)
          (let ((lookup-var
                 (seq-find (lambda (var)
                             (and var (boundp var) (symbol-value var)))
                           (cdr (assoc major-mode doom-modeline-indent-alist)) nil)))
            (funcall do-propertize "SPC:"
                     (if lookup-var
                         (symbol-value lookup-var)
                       tab-width)))))))

  ;;
  ;; Modeline Segments
  ;;

  (doom-modeline-def-modeline 'my/main
    '(" " my/bufler-workspace my/vcs bar window-number matches my/buffer-info remote-host parrot " " selection-info)
    '(objed-state grip irc mu4e gnus github debug repl lsp minor-modes process my/spellcheck checker input-method my/indent-info my/buffer-eol my/buffer-encoding major-mode my/buffer-position " "))

  ;;
  ;; Setup Modeline
  ;;

  (defun setup-initial-doom-modeline ()
    (interactive)
    (doom-modeline-set-modeline 'my/main 'default))

  :hook ((after-init . doom-modeline-mode)
         (doom-modeline-mode . setup-initial-doom-modeline)))

#+end_src

The default doom modeline, for reference:

#+begin_example

(doom-modeline-def-modeline 'main
  '(bar workspace-name window-number modals matches buffer-info remote-host buffer-position word-count parrot selection-info)
  '(objed-state misc-info persp-name battery grip irc mu4e gnus github debug repl lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs checker))

#+end_example

**** Package: spaceline                                         :notangle:

#+begin_src emacs-lisp

(use-package spaceline)

;(spaceline-toggle-minor-modes-off)
;(spaceline-toggle-buffer-modified-on)
;(spaceline-toggle-buffer-id-on)
;(spaceline-toggle-version-control-on)
;(spaceline-toggle-selection-info-on)
;(spaceline-toggle-input-method-on)
;(spaceline-toggle-buffer-encoding-abbrev-on)
;(spaceline-toggle-buffer-encoding-on)
;(spaceline-toggle-line-column-on)
;(spaceline-toggle-buffer-position-on)
;(spaceline-toggle-hud-off)

(spaceline-compile
  ; left side
  '(((persp-name)
     :fallback evil-state
     :face highlight-face
     :priority 100)
    (anzu :priority 95)
    auto-compile
    ((buffer-modified buffer-id remote-host)
     :priority 98)
    (major-mode :priority 79)
    (process :when active)
    ((flycheck-error flycheck-warning flycheck-info)
     :when active
     :priority 89)
    (erc-track :when active)
    (version-control :when active
                     :priority 78)
    )
  ; right side
  '(which-function
    (python-pyvenv :fallback python-pyenv)
    (purpose :priority 94)
    (selection-info :priority 95)
    input-method
    ((buffer-encoding-abbrev
      point-position
      line-column)
     :separator " | "
     :priority 96)
    (global :when active)
    (buffer-position :priority 99)
    (hud :priority 99)))

;;(spaceline-emacs-theme)

#+end_src

**** Package: telephone-line                                    :notangle:

#+begin_src emacs-lisp

(use-package telephone-line)

(telephone-line-defsegment* telephone-line-my-buffer-modified-segment ()
"Circle thatchanges color based on buffer modification status"
    (if (buffer-modified-p)
        (propertize (telephone-line-raw " ") 'face '(:foreground "dark orange" :weight bold))
      (telephone-line-raw " ")))

(telephone-line-defsegment* telephone-line-my-bufler-workspaces ()
"Display current bufler workspace name"
  (if (and (boundp 'bufler-workspace-tabs-mode) bufler-workspace-tabs-mode)
      (propertize (format " %s" (replace-regexp-in-string "Projectile:" "" (my/bufler-workspace-mode-lighter)))
                  'face '(:foreground "dark orange" :weight bold))
    "a"))


  (telephone-line-defsegment my-coding-segment ()
    (when (telephone-line-selected-window-active)
      (let* ((code (symbol-name buffer-file-coding-system))
             (eol-type (coding-system-eol-type buffer-file-coding-system))
             (eol (cond
                   ((eq 0 eol-type) "unix")
                   ((eq 1 eol-type) "dos")
                   ((eq 2 eol-type) "mac")
                   (t "-"))))
        (format  "%s " eol))))

(setq telephone-line-secondary-left-separator 'telephone-line-nil)

(defface my-red '((t (:foreground "white" :background "red3"))) "")
(defface my-cyan '((t (:foreground "dim grey" :background "cyan"))) "")

(setq telephone-line-faces
      '((evil . (my-red . my-red))
        (accent . (telephone-line-accent-active . telephone-line-accent-inactive))
        (nil . (mode-line . mode-line-inactive))))

(setq telephone-line-lhs
      '((evil   . (telephone-line-my-bufler-workspaces))
        (accent . (telephone-line-vc-segment
                   telephone-line-erc-modified-channels-segment
                   telephone-line-process-segment))
        (nil    . (telephone-line-my-buffer-modified-segment
                   telephone-line-file-name-absolute-path-segment))))
(setq telephone-line-rhs
      '((nil    . (telephone-line-atom-eol-segment
                   telephone-line-atom-encoding-segment))
        (accent . (telephone-line-major-mode-segment))
        (evil   . (telephone-line-airline-position-segment))))

(telephone-line-mode)

#+end_src

**** Package: mood-line                                         :notangle:

#+begin_src emacs-lisp

(use-package mood-line)
(setq mood-line-show-encoding-information t)
(setq mood-line-show-eol-style t)
(mood-line-mode)

#+end_src

**** bufler segment example                                     :notangle:

This part is the bufler modeline segment, without the doom-modeline specific stuff.
This can be used to define a segment for any modeline.

#+begin_src emacs-lisp

(doom-modeline-def-segment my/bufler-workspace
  "Display current bufler workspace name"
  (if (and (boundp 'bufler-workspace-tabs-mode) bufler-workspace-tabs-mode)
      (propertize (format "  %s" (replace-regexp-in-string "Projectile:" "" (my/bufler-workspace-mode-lighter)))
                  'face '(:foreground "gray60" :weight bold))
    ""))

;; note: should use something like (all-the-icons-alltheicon "git") instead

#+end_src

*** Search Across Directories
**** Information

There are plenty of choices for what to use here. My choice current choice is =rg=.

Other options are:
  - deadgrep
  - ripgrep
  - ag

**** Package: rg

#+begin_src emacs-lisp

(use-package rg
  :ensure-system-package (rg)

  :config
  (rg-define-search search-everything-regexp
    "Like normal rg command, but skips asking for file type"
    :query ask
    :format regexp
    :files "everything"
    :dir ask
    :flags ("--hidden"))

  (rg-define-search search-everything-regexp-project
    "Like normal rg command, but skips asking for file type.
Searches across current project."
    :query ask
    :format regexp
    :files "everything"
    :dir project
    :flags ("--hidden"))

  :bind
  (:map wakib-keys-overriding-map
        ("C-S-f" . search-everything-regexp)))

#+end_src

*** Interactive Visual Replace
**** Package: pcre2el

provides a regex backend to be used by visual-regexp-steroids
this is to avoid having python installed as a dependency

#+begin_src emacs-lisp

(use-package pcre2el)

#+end_src

**** Package: visual-regexp (part 1)

#+begin_src emacs-lisp

;; you can use actual regex with this package, instead of emacs specific regex
;; this seems better than Anzu for my uses
(use-package visual-regexp-steroids
  :ensure-system-package (python)
  :init
  ;; visual-regexp-steroids allows using python engine
  ;; (setq vr/engine 'pcre2el)

#+end_src

**** Package: visual-regexp (patch 1 - search whole buffer)

This is a change to allow searching the whole buffer.
Copied from a fork of the visual-regexp repository: https://github.com/grahnen/visual-regexp.el/commit/248f5716f8de092c1915d91821681aed7b31f808

#+begin_src emacs-lisp

(defvar vr--full-buffer 'nil)
(setq vr--full-buffer t)

(defun vr--set-target-buffer-start-end ()
  (if vr--full-buffer
      (setq vr--target-buffer-start (point-min)
            vr--target-buffer-end (point-max))
    (setq vr--target-buffer-start
          (if (region-active-p)
              (region-beginning)
            (point))
          vr--target-buffer-end
          (if (region-active-p)
              (region-end)
            (point-max)))))

#+end_src

**** Package: visual-regexp (patch 2 - use region as input)

This next part changes the package's base code to allow using active region as the input regex pattern.
The parts that were changed have comments that identify them.

#+begin_src emacs-lisp

:config
;; these are my own variables
(defvar my/visual-regexp-region-flag nil)
(defvar my/visual-regexp-region-val "default string")

;; use active region as replace regexp defeult input
(defun my/visual-replace-from-active-region (beginning end)
  "Normal `visual-replace', but use active region as input.
It assumes the region is active."
  (interactive "r")
  (setq my/visual-regexp-region-flag t)
  (setq my/visual-regexp-region-val (buffer-substring-no-properties (region-beginning) (region-end)))
  (goto-char beginning)
  (deactivate-mark)
  (call-interactively 'vr/query-replace))

;; wrapper function that checks if there is an active region or not
(defun my/visual-replace-with-active-region-support ()
  "Normal `visual-replace', but check if there's an active region first."
  (interactive)
  (when (eq major-mode 'org-mode)
    (outline-show-all))
  (if (region-active-p)
      (call-interactively 'my/visual-replace-from-active-region)
    (call-interactively 'vr/query-replace)))

;; this is the core function that was changed
(defun vr--set-regexp-string ()
  (save-excursion
    ;; deactivate mark so that we can see our faces instead of region-face.
    (deactivate-mark)
    (setq vr--in-minibuffer 'vr--minibuffer-regexp)
    (setq vr--last-minibuffer-contents "")
    (custom-reevaluate-setting 'vr/match-separator-string)
    (let* ((minibuffer-allow-text-properties t)
           (history-add-new-input nil)
           (text-property-default-nonsticky
            (cons '(separator . t) text-property-default-nonsticky))
           ;; seperator and query-replace-from-to-history copy/pasted from replace.el
           (separator
            (when vr/match-separator-string
              (propertize "\0"
                          'display vr/match-separator-string
                          'separator t)))
           (query-replace-from-to-history
            (append
             (when separator
               (mapcar (lambda (from-to)
                         (concat (query-replace-descr (car from-to))
                                 separator
                                 (query-replace-descr (cdr from-to))))
                       (symbol-value vr/query-replace-defaults-variable)))
             (symbol-value vr/query-replace-from-history-variable)))

           ;; Changes I made: the next two lines
           (my-var my/visual-regexp-region-flag))
      (setq my/visual-regexp-region-flag nil)

      (setq vr--regexp-string
            (read-from-minibuffer
             " " ;; prompt will be set in vr--minibuffer-setup

             ;; I also added these three lines
             (if my-var
                 my/visual-regexp-region-val
               nil)

             vr/minibuffer-keymap
             nil 'query-replace-from-to-history))
      (let ((split (vr--query-replace--split-string vr--regexp-string)))
        (if (not (consp split))
            (add-to-history vr/query-replace-from-history-variable vr--regexp-string nil t)
          (add-to-history vr/query-replace-from-history-variable (car split) nil t)
          (add-to-history vr/query-replace-to-history-variable (cdr split) nil t)
          (add-to-history vr/query-replace-defaults-variable split nil t))))))

#+end_src

**** Package: visual-regexp (part 2)

#+begin_src emacs-lisp

:bind
;; (:map wakib-keys-overriding-map
;;       ("C-h" . my/visual-replace-with-active-region-support)))

((:map wakib-keys-overriding-map
       ("C-r" . my/visual-replace-with-active-region-support))
 ;; ("C-h" . my/visual-replace-with-active-region-support)
 ))

;; using C-7 inside swiper seems better. it does the same thing
;; (bind-key "C-S-h" 'vr/mc-mark wakib-keys-overriding-map)

#+end_src


This is how the author of the package suggests implementing thing-at-point in a github issue:

(defvar vr-current-thing-at-point nil)
(defun vr-thing-at-point-minibuffer-setup ()
  (when (and vr-current-thing-at-point
             (equal vr--in-minibuffer 'vr--minibuffer-regexp))
    (insert vr-current-thing-at-point)))
(add-hook 'minibuffer-setup-hook 'vr-thing-at-point-minibuffer-setup)

(defun vr-thing-at-point ()
  (interactive)
  (let ((vr-current-thing-at-point (thing-at-point 'symbol t)))
    (call-interactively 'vr/query-replace)))

**** test: display matches in folded org headings               :notangle:

an attempt to replicate anzu and swiper behaviour.
they open a heading when there's an entry in there and fold it back when moving to the next heading.
they final view is the same as before the command executed.

#+begin_src emacs-lisp

(defun vr--perform-query-replace ()
  ;; This function is a heavily modified version of (perform-replace) from replace.el.
  ;; The original plan was to use the original perform-replace, but various issues stood in the way.
  (and minibuffer-auto-raise
       (raise-frame (window-frame (minibuffer-window))))
  (let* ((from-string (vr--get-regexp-string))
         (map vr--query-replace-map)
         (vr--query-replacements (nreverse (car (vr--get-replacements nil nil))))
         (next-replacement nil) ;; replacement string for current match
         (keep-going t)
         (replace-count 0)
         ;; a match can be replaced by a longer/shorter replacement. cumulate the difference
         (cumulative-offset 0)
         (recenter-last-op nil) ; Start cycling order with initial position.
         (message
          (concat
           (propertize "Replacing " 'read-only t)
           (propertize "%s" 'read-only t 'face 'font-lock-keyword-face)
           (propertize " with " 'read-only t)
           (propertize "%s" 'read-only t 'face 'font-lock-keyword-face)
           (propertize (substitute-command-keys
                        " (\\<vr--query-replace-map>\\[help] for help) ")
                       'read-only t))))

    ;; show visual feedback for all matches
    (mapc (lambda (replacement-info)
            (cl-multiple-value-bind (replacement match-data i) replacement-info
              (vr--feedback-match-callback i 0 (cl-first match-data) (cl-second match-data))))
          vr--query-replacements)

    (goto-char vr--target-buffer-start)
    (push-mark)
    (undo-boundary)
    (unwind-protect
        ;; Loop finding occurrences that perhaps should be replaced.
        (while (and keep-going vr--query-replacements)
          ;; Advance replacement list
          (cl-multiple-value-bind (replacement match-data i) (car vr--query-replacements)
            (setq match-data (vr--mapcar-nonnil (lambda (el) (+ cumulative-offset el)) match-data))
            (let ((begin (cl-first match-data))
                  (end (cl-second match-data))
                  (next-replacement-orig replacement))
              (setq next-replacement (vr--get-replacement replacement match-data replace-count))
              (goto-char begin)
              (setq vr--query-replacements (cdr vr--query-replacements))

              ;; default for new occurrence: no preview
              (setq vr--replace-preview nil)

              (undo-boundary)
              (let (done replaced key def)
                ;; Loop reading commands until one of them sets done,
                ;; which means it has finished handling this
                ;; occurrence.
                (while (not done)


                  (outline-show-subtree)
                  ;; (outline-previous-heading)
                  ;; (outline-show-entry)


                  ;; show replacement feedback for current occurrence
                  (unless replaced
                    (vr--do-replace-feedback-match-callback next-replacement-orig match-data i))
                  ;; Bind message-log-max so we don't fill up the message log
                  ;; with a bunch of identical messages.
                  (let ((message-log-max nil))
                    (message message from-string next-replacement))
                  (setq key (read-event))
                  (setq key (vector key))
                  (setq def (lookup-key map key))

                  ;; can use replace-match afterwards
                  (set-match-data match-data)

                  ;; Restore the match data while we process the command.
                  (cond ((eq def 'help)
                         (with-output-to-temp-buffer "*Help*"
                           (princ
                            (concat "Query replacing visual-regexp "
                                    from-string " with "
                                    next-replacement ".\n\n"
                                    (substitute-command-keys
                                     vr--query-replace-help)))
                           (with-current-buffer standard-output
                             (help-mode))))
                        ((eq def 'exit)
                         (setq keep-going nil
                               done t))
                        ((eq def 'act)
                         (unless replaced
                           (replace-match next-replacement t t)
                           (setq replace-count (1+ replace-count)))
                         (setq done t
                               replaced t))
                        ((eq def 'act-and-exit)
                         (unless replaced
                           (replace-match next-replacement t t)
                           (setq replace-count (1+ replace-count)))
                         (setq keep-going nil
                               done t
                               replaced t))
                        ((eq def 'act-and-show)
                         (unless replaced
                           (replace-match next-replacement t t)
                           (setq replace-count (1+ replace-count))
                           (setq replaced t)))
                        ((eq def 'toggle-preview)
                         (setq vr--replace-preview (not vr--replace-preview)))
                        ((eq def 'automatic)
                         (setq vr--target-buffer-start (match-beginning 0)
                               vr--target-buffer-end (+ cumulative-offset vr--target-buffer-end))
                         (setq replace-count (+ replace-count (vr--do-replace t)))
                         (setq done t
                               replaced t
                               keep-going nil))
                        ((eq def 'skip)
                         (setq done t))
                        ((eq def 'recenter)
                         ;; `this-command' has the value `query-replace',
                         ;; so we need to bind it to `recenter-top-bottom'
                         ;; to allow it to detect a sequence of `C-l'.
                         (let ((this-command 'recenter-top-bottom)
                               (last-command 'recenter-top-bottom))
                           (recenter-top-bottom)))
                        (t
                         (setq this-command 'mode-exited)
                         (setq keep-going nil)
                         (setq unread-command-events
                               (append (listify-key-sequence key)
                                       unread-command-events))
                         (setq done t)))
                  (when replaced
                    (setq cumulative-offset (+ cumulative-offset (- (length next-replacement) (- end begin)))))
                  (unless (eq def 'recenter)
                    ;; Reset recenter cycling order to initial position.
                    (setq recenter-last-op nil))
                  ;; in case of 'act-and-show: delete overlay display or it will still be
                  ;; visible even though the replacement has been made
                  (when replaced (vr--delete-overlay-display (vr--get-overlay i 0)))))

              ;; occurrence has been handled
              ;; delete feedback overlay
              (delete-overlay (vr--get-overlay i 0)))))

      ;; unwind
      (progn
        (vr--delete-overlay-displays)
        (vr--delete-overlays)
        ;; (replace-dehighlight)
        ))
    (unless unread-command-events
      ;; point is set to the end of the last occurrence.
      (goto-char (match-end 0))
      (message "Replaced %d occurrence%s"
               replace-count
               (if (= replace-count 1) "" "s")))))

#+end_src

*** Org mode
**** Package: async

The code below executes org-babel-tangle asynchronously when the config file is saved.

#+begin_src emacs-lisp

(use-package async
  :config
  (defvar *config-last-change* (nth 5 (file-attributes *config-file*))
    "Last modification time of the configuration file.")

  (defvar *show-async-tangle-results* nil
    "Keeps *emacs* async buffers around for later inspection.")

  (defun my/config-updated ()
    "Checks if the configuration file has been updated since the last time."
    (time-less-p *config-last-change*
                 (nth 5 (file-attributes *config-file*))))

  (defun my/config-tangle ()
    "Tangles the user configuration org file asynchronously."
    (when (my/config-updated)
      (setq *config-last-change*
            (nth 5 (file-attributes *config-file*)))
      (my/async-babel-tangle *config-file*)))

  (defun my/async-babel-tangle (org-file)
    "Tangles an org file asynchronously."
    (let ((init-tangle-start-time (current-time))
          (file (buffer-file-name))
          (async-quiet-switch "-q"))
      ;; (org-babel-tangle-file org-file)
      (async-start
       `(lambda ()
          ;; (require 'org)
          (load-file (expand-file-name "base/resources/tangle-patch.el" user-emacs-directory))
          (org-babel-tangle-file ,org-file))
       (unless *show-async-tangle-results*
         `(lambda (result)
            (if result
                (message "SUCCESS: %s successfully tangled (%.2fs)."
                         ,org-file
                         (float-time (time-subtract (current-time)
                                                    ',init-tangle-start-time)))
              (message "ERROR: %s as tangle failed." ,org-file))))))))

#+end_src

**** Package: org

#+begin_src emacs-lisp

(use-package org
  :ensure org-plus-contrib
  :demand t
  :config
  (setq org-startup-indented                 t             ;; indent text to heading level
        org-startup-folded                   'overview     ;; set initial view to 'content' (show all headlines)
        org-indent-indentation-per-level     2
        org-export-exclude-tags              '("NOEXPORT")
        org-descriptive-links                t             ;; highlight links
        org-cycle-separator-lines            2             ;; set how may real newlines are necessary to display a newline when folded.
        org-todo-keywords                    '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")   ;; default todo keywords ✔ ✘
                                               (sequence "SOMEDAY(s)" "WAITING(w)" "PAUSED(p)" "REVIEW(r)" "|" "CANCELLED(c)"))
        org-todo-repeat-to-state             "NEXT"
        org-todo-keyword-faces               '(("TODO" . "#efcb82")
                                               ("SOMEDAY" . "#3dc7f0")
                                               ("WAITING" . "#3dc7f0")
                                               ("PAUSED"  . "#3dc7f0")
                                               ("REVIEW"  . "#3dc7f0"))
        org-log-done                         (quote time)  ;; insert a note in a task when it is marked as done, which includes a timestamp
        org-support-shift-select             t             ;; allows using the shif key for selecting text
        org-fontify-done-headline            t             ;; grey out completed tasks
        org-src-preserve-indentation         t             ;; do not put two spaces on the left
        org-src-tab-acts-natively            t             ;; make tab behave as it would normally for that language
        org-ellipsis                         " ⤵"          ;; Changing the org-mode ellipsis
        ;; setq org-ellipsis                 " ▼"
        org-image-actual-width               nil           ;; if there is something like #+ATTR_ORG: width="200", resize to 200, otherwise don't resize
        org-confirm-babel-evaluate           nil
        org-blank-before-new-entry           '((heading . auto)              ;; Disable blank line on new heading
                                               (plain-list-item . auto))
        org-show-context-detail              '((agenda . local)
                                               (default . lineage)))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (python . t)
     (emacs-lisp . t)))

  ;; (setq org-log-into-drawer "LOGBOOK")

  :bind
  (:map org-mode-map
        ("C-d <C-left>" . org-backward-element)
        ("C-d <C-right>" . org-forward-element)
        ("C-d <C-up>" . org-up-element)
        ("C-d <C-down>" . org-down-element)
        ;; allow C-S-<arrow> selection of text
        ("<C-S-left>" .  nil)
        ("<C-S-right>" .  nil)
        ("<C-S-up>" .  nil)
        ("<C-S-down>" .  nil)
        ("<end>" . end-of-visual-line))  ;; When in heading, put cursor after ellipsis

  :hook ((after-save . my/config-tangle)
         (org-mode . (lambda () (prettify-symbols-mode)))
         (org-agenda-mode . (lambda () (display-line-numbers-mode -1)))))

#+end_src

**** Package: org-superstar

#+begin_src emacs-lisp

(use-package org-superstar
  :after org
  :custom
  (org-superstar-headline-bullets-list '("◈" "❖" "✽" "✲" "✜" "✛" "✝" "†"))
  (org-superstar-item-bullet-alist '((?* . ?►)
                                     (?+ . ?○)
                                     (?- . ?●)))

  ;; Go through the bullet list, then repeat the last entry indefinitely.
  (org-superstar-cycle-headline-bullets nil)

  ;; ;; superstar has a more agressive way of removing leading stars
  ;; (org-hide-leading-stars nil)
  ;; (org-superstar-remove-leading-stars t)

  :hook (org-mode . org-superstar-mode))

#+end_src

**** org-superstar: Testing extra features                      :notangle:

Here are some symbols that can be used for Org headings:

"✙" "♱" "♰" "☥" "✞" "✟" "✝" "†" "✠" "✚" "✜" "✛" "✢" "✣" "✤" "✥"
"◉" "◈"
"●" "○" "■" "□" "▶" "▷" "►" "▻"
"◆" "◇" "◈" "◉" "◊" "○" "◌" "◎" "●"
"❖" "➕"
"✩" "✪" "✫" "✬" "✭" "✮" "✯" "✰" "✱" "✲" "✳" "✴" "✵" "✶" "✷" "✸" "✹" "✺" "✻" "✼" "✽" "✾" "✿" "❀" "❁" "❂" "❃" "❄" "❅" "❆" "❇" "❈" "❉" "❊" "❋"
"✙" "✚" "✛" "✜" "✝" "✞" "✟" "✠" "✡" "✢" "✣" "✤" "✥" "✦" "✧"

And here are some code samples from  the repo, showing some possibilities:

This time we want all of the above but a little more personalized. First off, let’s make bullets a little more chunky. Mind that the height we provide for bullet faces is not the actual height of a bullet, but its height relative to its surroundings. Additionally, let’s hide the leading stars for terminal sessions, as the default leader does not look all that good in my chosen terminal font. I make use of the fact that org-superstar-leading-fallback can be set to the space character. This has the nice advantage over org-hide-leading-stars that it does not just “paint over” the asterisks, but makes them completely indistinguishable from white space, neat!

#+begin_src emacs-lisp

(with-eval-after-load 'org-superstar
  (set-face-attribute 'org-superstar-item nil :height 1.2)
  (set-face-attribute 'org-superstar-header-bullet nil :height 1.2)
  (set-face-attribute 'org-superstar-leading nil :height 1.3))
;; Set different bullets, with one getting a terminal fallback.
(setq org-superstar-headline-bullets-list
      '("◉" ("🞛" ?◈) "○" "▷"))
;; Stop cycling bullets to emphasize hierarchy of headlines.
(setq org-superstar-cycle-headline-bullets nil)
;; Hide away leading stars on terminal.
(setq org-superstar-leading-fallback ?\s)

#+end_src


Inline tasks behave as you would expect them to, for the most part. They have two bullets instead of one, but are otherwise treated the same as regular headlines by Org Superstar, meaning org-superstar-headline-bullets-list controls the bullet used as if it were a regular headline. If org-inlinetask-show-first-star is non-nil, you can customize the additional marker. Just like with the rest of Superstar’s decorations, you can more or less fully control how it looks, with independent settings for graphical and terminal displays and a dedicated face, should you find the default of using org-warn a little… unsubtle. We again use the LaTeX setup as a base and add a few tweaks.

#+begin_src emacs-lisp

(require 'org-inlinetask)
(setq org-inlinetask-show-first-star t)
;; Less gray please.
(set-face-attribute 'org-inlinetask nil
                    :foreground nil
		      :inherit 'bold)
(with-eval-after-load 'org-superstar
  (set-face-attribute 'org-superstar-first nil
                      :foreground "#9000e1"))
;; Set different bullets, with one getting a terminal fallback.
(setq org-superstar-headline-bullets-list
      '("◉" ("🞛" ?◈) "○" "▷"))
;; Set up a different marker for graphic display.
(setq org-superstar-first-inlinetask-bullet ?🞸)
;; Stop cycling bullets to emphasize hierarchy of headlines.
(setq org-superstar-cycle-headline-bullets nil)
;; A simple period works fine, too.
(setq org-superstar-leading-fallback ?.)

#+end_src

**** Package: toc-org

#+begin_src emacs-lisp

(use-package toc-org
  :hook (org-mode . toc-org-mode))

#+end_src

**** REVIEW Package: org-ql

#+begin_src emacs-lisp

(use-package org-ql)

#+end_src

**** Feature: Org notes

# Note: org-directory needs to be defined before the org-agenda block

#+begin_src emacs-lisp

(setq org-directory                        "~/Cloud/Work - Google Cloud/Org/"    ;; where to look for org files
      org-default-notes-file               (expand-file-name "notes/notes.org" org-directory))

#+end_src

**** Feature: Org inbox

#+begin_src emacs-lisp

(setq my/org-inbox-file                    (expand-file-name "inbox.org" org-directory))

#+end_src

**** Package: org-agenda

#+begin_src emacs-lisp

(use-package org-agenda
  :straight org
  :config
  (setq org-agenda-files                     `(,org-directory
                                               ,(expand-file-name "agenda/private" org-directory)
                                               ,(expand-file-name "agenda/projects" org-directory)
                                               ,(expand-file-name "agenda/projects/IST/year 5" org-directory))
        org-agenda-dim-blocked-tasks         t             ;; dim blocked tasks
        org-agenda-skip-deadline-if-done     t             ;; avoid showing unecessary tasks
        org-agenda-skip-scheduled-if-done    t
        org-agenda-skip-archived-trees       t
        org-agenda-skip-deadline-prewarning-if-scheduled t
        ;; org-agenda-span                      30            ;; amount of days in the agenda
        org-agenda-start-on-weekday          nil           ;; start the agenda in the current day
        org-agenda-prefix-format             '((agenda . " %i %-25:c%?-25t% s")    ;; make the first column in agenda wider (default is 12 characters)
                                               (todo . " %i %-25:c")
                                               (tags . " %i %-25:c")
                                               (search . " %i %-25:c"))
        org-agenda-window-setup              'only-window)

  (setq org-agenda-custom-commands
        '(("a" "Agenda and all NEXT items"
           ((agenda "")
            (todo "NEXT"))
           ((org-agenda-todo-ignore-with-date t)))
          ;; ("cm" "Custom: This month"
          ;;  ((org-ql-block '(ts-active :from today :to (format-time-string "%Y-%m-%d" (org-read-date nil t "+30d")))
          ;;                  ((org-ql-block-header "This month")))
          ;;   (agenda)))
          )))

#+end_src

**** REVIEW Package: org-super-agenda

#+begin_src emacs-lisp

(require 'org-habit)
(use-package org-super-agenda
  :config
  ;; (let ((one-week-from-today (format-time-string "%Y-%m-%d" (org-read-date nil t "+1w")))
  ;;       (one-month-from-today (format-time-string "%Y-%m-%d" (org-read-date nil t "+30d"))))
  ;;   (setq org-super-agenda-groups
  ;;         `(
  ;;           (:name "Due within week"
  ;;                  :deadline (before ,one-week-from-today)
  ;;                  :order 0)
  ;;           (:name "Due within month"
  ;;                  :deadline (before ,one-month-from-today)
  ;;                  :order 1)
  ;;           ;; (:discard)
  ;;           )))
  ;; (setq org-super-agenda-groups
  ;;       `(
  ;;         (:name "Do ASAP"
  ;;                :priority "A"
  ;;                :order 0)
  ;;         (:name "Do soon"
  ;;                :priority "B"
  ;;                :order 1)
  ;;         (:name "Do Eventually"
  ;;                :priority "C"
  ;;                :order 2)
  ;;         (:discard)
  ;;         ))
  (org-super-agenda-mode))

#+end_src

**** Feature: simple headings for special org files (lists)

After choosing a face and a list of org files, any headings in one of those files that has a todo state will have the defined face applied.
This is useful for org files with lists, like watch lists for Movies, Anime, Books, etc.
It allows for the list entries to be visually different from normal headings.

I would like to be able to activate this from the file itself, but the problem is that =org-font-lock-set-keywords-hook= is a global value.

#+begin_src emacs-lisp

(defface my/org-simple-headline '((t (:inherit default)))
  "Simple face for org headings."
  :group 'org-faces)

(defvar my/org-simple-headlines-files (list "Manga list.org" "Anime list.org")
  "Files where simple headings are desired.")

(defun my/org-fontify-simple-headlines ()
  "Fontify any headings with a todo keyword, in selected files."
  (when (member (buffer-name) my/org-simple-headlines-files)
    (push (list (format org-heading-keyword-regexp-format
                        (concat
                         "\\(?:"
                         (mapconcat 'regexp-quote org-todo-keywords-1 "\\|")
                         "\\)"))
                '(2 'my/org-simple-headline t))
          org-font-lock-extra-keywords)))

(add-hook 'org-font-lock-set-keywords-hook #'my/org-fontify-simple-headlines)

#+end_src

**** Notes and basic usage

Emphasis: when to use = or ~
~ is for code, functions, or things that can be executed
= is for general emphasis

*** Modal editing
**** REVIEW Package: ryo-modal

try out a modal configuration

C-up gives error: "wrong number of arguments: (0 . 1), 2"
related to org-backward-paragraph
it works if I manually execute the use-package after emacs is loaded. probably a dependency issue.

after some experimentation, is seems there's a conflict with some org package.
Solution: load this package after the org section.

#+begin_src emacs-lisp

(use-package ryo-modal
  :commands ryo-modal-mode
  ;; :init
  ;; (unbind-key "C-SPC")
  :config
  (setq ryo-modal-cursor-color "white")

  (bind-key "M-j" 'drag-stuff-left wakib-keys-overriding-map)
  (bind-key "M-l" 'drag-stuff-right wakib-keys-overriding-map)
  (bind-key "M-i" 'drag-stuff-up wakib-keys-overriding-map)
  (bind-key "M-k" 'drag-stuff-down wakib-keys-overriding-map)

  (bind-key "M-p" 'my/smarter-move-beginning-of-line wakib-keys-overriding-map)
  (bind-key "M-+" 'end-of-visual-line wakib-keys-overriding-map)
  (bind-key "M-ç" 'scroll-down-command wakib-keys-overriding-map)
  (bind-key "M-º" 'scroll-up-command wakib-keys-overriding-map)

  (ryo-modal-keys
   ("," ryo-modal-repeat)
   ("q" ryo-modal-mode)
   ("i" previous-line)
   ("k" next-line)
   ("j" backward-char)
   ("l" forward-char)
   ;; ("u" )
   ;; ("o" )
   ("I" backward-paragraph)
   ("K" forward-paragraph)
   ("J" backward-word)
   ("L" forward-word)
   ;; ("U" )
   ;; ("O" )
   ("[" backward-sexp)
   ("]" forward-sexp)
   ("{" backward-up-list)
   ("}" down-list)
   )

  (ryo-modal-keys
   ;; First argument to ryo-modal-keys may be a list of keywords.
   ;; These keywords will be applied to all keybindings.
   (:norepeat t)
   ("0" "M-0")
   ("1" "M-1")
   ("2" "M-2")
   ("3" "M-3")
   ("4" "M-4")
   ("5" "M-5")
   ("6" "M-6")
   ("7" "M-7")
   ("8" "M-8")
   ("9" "M-9"))

  ;; :bind
  ;; ("C-SPC" . ryo-modal-mode)
  ;; :hook
  ;; ((after-init . ryo-modal-mode))
  )

#+end_src

*** Spellcheck
**** Package: flyspell

Between aspell and hunspell, aspell seems to have much better performance.

#+begin_src emacs-lisp

;; defer is used to only load package when mode is activated
(use-package flyspell
  :ensure-system-package (aspell)
  :defer t
  :config
  ;; set backend and default language
  (setq ispell-program-name    "aspell"
        ispell-dictionary      "en_US")

  :bind
  (:map wakib-keys-overriding-map
        ("C-." . flyspell-correct-at-point))

  :hook
  ((org-mode . flyspell-mode)            ;; automatically enable spellchecker for org files (doesn't affect source blocks)
   (prog-mode . flyspell-prog-mode)))    ;; only for comments and strings

#+end_src

**** Package: flyspell-correct-ivy

#+begin_src emacs-lisp

(use-package flyspell-correct-ivy
  :config
  (setq flyspell-correct-interface #'flyspell-correct-ivy)
  :bind
  (:map flyspell-mouse-map
   ("<mouse-2>" . nil)
   ("<mouse-3>" . flyspell-correct-word)))

#+end_src

**** Notes and basic usage

Use hydra menu to enable/disable.

*** Code Completion
**** Package: company

#+begin_src emacs-lisp

(use-package company
  :config

  (setq company-global-modes             '(not org-mode)
        company-minimum-prefix-length    3
        company-auto-complete            t
        company-show-numbers             t
        company-idle-delay               0.6)

  (defun company-abort-and-insert-space ()
    (interactive)
    (company-abort)
    (insert " "))

  :bind
  (:map company-active-map
        ("<escape>" . company-abort)
        ("SPC" . company-abort-and-insert-space))
  :hook
  (after-init . global-company-mode))

#+end_src

**** REVIEW Package: company-quickhelp

#+begin_src emacs-lisp

(use-package company-quickhelp
  :unless (display-graphic-p)
  :after company
  :init
  (setq company-quickhelp-delay nil)  ;; popup doesnt appear automatically
  :config
  (company-quickhelp-mode))

#+end_src

**** REVIEW Package: company-box

#+begin_src emacs-lisp

(use-package company-box
  :after company
  :hook
  (company-mode . (lambda () (when (display-graphic-p) (company-box-mode)))))

#+end_src

*** Emacs Completion Framework
**** Information

Helm and ivy are Emacs frameworks for incremental completions and narrowing selections.

Completion framework being used:

Ivy + Swiper + Counsel

ivy is the mechanism that handles all selection lists, narrowing
    them down using a variety of possible builders (regular expressions of
    flexible matching).  It also provides a base interface for any
    function that needs to receive input based on a list of candidates.

counsel provides a superset of functions for navigating the file
    system, switching buffers, etc. that expand on the basic features
    supported by Ivy.  For instance, switching buffers with Counsel offers
    a preview of their contents in the window, whereas regular Ivy does
    not.

swiper is a tool for performing searches, powered by Ivy, all while
    presenting a preview of the results.

**** Package: ivy

#+begin_src emacs-lisp

(use-package ivy
  :defer 0.1
  :diminish
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-count-format "%d/%d ")
  (ivy-wrap t)
  (ivy-initial-inputs-alist nil)
  :config
  (ivy-mode)
  :bind
  (:map ivy-minibuffer-map
        ("TAB" . ivy-alt-done)))

#+end_src

**** Package: counsel

#+begin_src emacs-lisp

(use-package counsel
  :after ivy
  :config
  (counsel-mode)

  (defun my/counsel-fzf-directory ()
    "Starts a fzf session at the specified directory."
    (interactive)
    (counsel-fzf "" (counsel-read-directory-name "Directory: " fzf/directory-start) "File: "))

  :bind
  (:map wakib-keys-overriding-map
        ("C-b" . counsel-bookmark)
        ("C-o" . counsel-find-file)))

#+end_src

**** Package: swiper

#+begin_src emacs-lisp

(use-package swiper
  :after ivy
  :config
  (defun my/swiper-isearch-with-selection ()
    "Swiper-isearch, but uses active selection as input if it exists"
    (interactive)
    (if (region-active-p) (swiper-isearch-thing-at-point)
      (swiper-isearch nil)))

  ;; this function isn't being used. just for reference.
  (defun my/swiper-isearch-again-with-selection ()
    "Start swiper-isearch with the last thing searched for.
Uses the active region as input, if it is active."
    (interactive)
    (if (region-active-p) (swiper-isearch-thing-at-point)
      (swiper-isearch (car swiper-history))
      ))

  (defun my/swiper-isearch-again ()
    "Start swiper-isearch with the last thing searched for."
    (interactive)
    (deactivate-mark)
    (swiper-isearch (car swiper-history)))

  (defun my/swiper-isearch-again-backward ()
    "Start swiper-isearch with the last thing searched for.
    Search backward."
    (interactive)
    (deactivate-mark)
    (swiper-isearch-backward (car swiper-history)))

  :bind
  (("<f3>" . my/swiper-isearch-again)
   ("<S-f3>" . my/swiper-isearch-again-backward)
   :map wakib-keys-overriding-map
   ("C-f" . my/swiper-isearch-with-selection)   ;; replace 'isearch' with swiper
   :map swiper-isearch-map
   ("<f3>" . next-line)
   ("<S-f3>" . previous-line)
   ;; cant use C-m for swiper-mc. when doing that, every time enter is pressed after search, swiper-mc is activated
   ("C-r" . swiper-mc)  ;; swiper-mc puts a cursor on every swiper search result
   ))

#+end_src

**** Package: flx

Ivy sorts large lists using flx's scoring mechanism, if it's installed.

#+begin_src emacs-lisp

(use-package flx)

#+end_src

**** Package: ivy-prescient

If ivy-prescient is not being used, then put the =ivy-re-builders-alist= declaration in the =ivy= package.

#+begin_src emacs-lisp

(use-package prescient
  :after (counsel)
  :custom
  (prescient-history-length 50)
  (prescient-filter-method '(literal regexp))
  :config
  (prescient-persist-mode 1))

(use-package ivy-prescient
  :after (prescient ivy)
  :custom
  (ivy-prescient-sort-commands
   ;; things that shouldnt be sorted go in this list
   '(:not swiper swiper-isearch ivy-switch-buffer counsel-switch-buffer flyspell-correct-ivy counsel-find-file find-file bufler-workspace-switch-buffer bufler-switch-buffer counsel-fzf counsel-imenu counsel-file-jump))
  (ivy-prescient-excluded-commands '(counsel-find-file find-file))
  (ivy-prescient-retain-classic-highlighting t)
  (ivy-prescient-enable-filtering nil)
  (ivy-prescient-enable-sorting t)
  (ivy-re-builders-alist
   '((t . ivy--regex-ignore-order)
     (counsel-M-x . ivy--regex-ignore-order)
     (swiper-isearch . ivy--regex-plus)
     (swiper-isearch-backward . ivy--regex-plus)
     (swiper-isearch-thing-at-point . ivy--regex-plus)))
  :config
  (ivy-prescient-mode 1))

#+end_src

**** Package: ivy-rich

#+begin_src emacs-lisp

(use-package ivy-rich
  :after ivy
  :custom
  (ivy-rich-path-style 'abbreviate)
  :config
  (setcdr (assq t ivy-format-functions-alist)
          #'ivy-format-function-line)
  (ivy-rich-mode 1))

(use-package all-the-icons-ivy-rich
  :after ivy-rich
  :custom
  (all-the-icons-ivy-rich-icon-size 1.0)
  :config (all-the-icons-ivy-rich-mode 1))

#+end_src

**** Package: ivy-posframe

#+begin_src emacs-lisp

(use-package ivy-posframe
  :after ivy
  :custom
  (ivy-posframe-parameters
   '((left-fringe           . 2)
     (right-fringe          . 2)
     (internal-border-width . 2)))
  (ivy-posframe-height-alist
   '((swiper                . 15)
     (swiper-isearch        . 1)
     (flyspell-correct-ivy  . 10)
     (t . 20)))
  (ivy-posframe-display-functions-alist
   '((complete-symbol       . ivy-posframe-display-at-point)
     (swiper                . ivy-display-function-fallback)
     (swiper-isearch        . ivy-display-function-fallback)
     (flyspell-correct-ivy  . ivy-posframe-display-at-point)
     (t                     . ivy-posframe-display-at-frame-center)))
  :config (ivy-posframe-mode 1))

#+end_src

**** Package: counsel-projectile

#+begin_src emacs-lisp

(use-package counsel-projectile
  :after counsel)

#+end_src

**** Notes and basic usage

When using swiper, press C-7 to add a cursor to all highlighted items

*** Git Integration
**** Package: magit

#+begin_quote
Magit is a complete text-based user interface to Git. It fills the glaring gap between the Git command-line interface and various GUIs, letting you perform trivial as well as elaborate version control tasks with just a couple of mnemonic key presses.
#+end_quote

#+begin_src emacs-lisp

(use-package magit
  :ensure-system-package (git)
  :hook (magit-mode . my/set-buffer-large-fringe))

#+end_src

**** Package: diff-hl

#+begin_quote
Emacs package for highlighting uncommitted changes
#+end_quote

By default, changes are displayed in the fringe.

#+begin_src emacs-lisp

(use-package diff-hl
  :config
  (diff-hl-flydiff-mode)  ;; see changes in real time

  :hook ((magit-pre-refresh . diff-hl-magit-pre-refresh)
         (magit-post-refresh . diff-hl-magit-post-refresh)
         (prog-mode . diff-hl-mode)))

#+end_src

**** Package: git-gutter                                        :notangle:

#+begin_src emacs-lisp

(use-package git-gutter
  :config
  (setq git-gutter:update-interval 1)
  (global-git-gutter-mode)

  ;; lines that are 'inserted' cause problems with org headings ellipsis symbol
  (defun disable-gutter()
    (interactive)
    (diff-hl-mode 0))

  :hook
  (org-mode . disable-gutter))

#+end_src

**** git-ml.el

Taken from https://gist.github.com/pkkm/3be34dd19622e194eca4653782f616c8
It's not available in a melpa package, so the whole package is in the following snippet.

#+begin_src emacs-lisp

;;; Asynchronous detailed git modeline.

;; git-ml is free software: you can redistribute it and/or modify it under the
;; terms of the GNU General Public License as published by the Free Software
;; Foundation, either version 3 of the License, or (at your option) any later
;; version.

;; This is a rough sketch. Things to do before publishing it as a package:
;;
;; * Consider doing the checks per git directory instead of per buffer, then
;;   propagating the results to all buffers which use this directory. Read
;;   vc-mode's implementation -- does it do things this way or just calculate
;;   the modeline for every buffer separately?
;;
;; * Distinguish changes in the current file from changes in other files. Use
;;   brackets, box, underline, etc. For example, display " master ✚1 [•1]" when
;;   the current file has a staged change and there's another file with an
;;   unstaged change.
;;
;; * Handle errors by stopping the remaining processes and passing nil to
;;   git-ml-render-function.
;;
;; * Ensure that we never start the processes multiple times, even if the user
;;   does many refreshes in quick succession.
;;
;; * Use a timeout for the processes.
;;
;; * Kill the processes when they're no longer needed because the user has
;;   killed the buffer(s).
;;
;; * Hook into magit to refresh the modeline after it executes commands.
;;
;; * Refresh the git state in an idle timer.
;;
;; * Document the result struct in git-ml-render-function's docstring.
;;
;; * Consider using one of the async/await libraries. They don't seem popular
;;   though, so not sure if it's a good idea.
;;
;; * Consider turning the file into a global minor mode.
;;
;; * Consider changing the git-ml prefix.

;; How to use:
;; 1. Add `git-ml' to your mode line, e.g. `(... vc-mode git-ml ...)'
;; 2. If you only use `vc-mode' for its modeline, you probably want to disable
;;    it for git: `(setq vc-handled-backends (delq 'Git vc-handled-backends))'.
;; 3. `(git-ml-activate)'.

;; Inspiration (ideas):
;; * https://github.com/romkatv/powerlevel10k
;; * https://github.com/yonchu/zsh-vcs-prompt

;; Inspiration (implementation):
;; * https://github.com/zsh-users/zsh/blob/2f2aa36/Functions/VCS_Info/Backends/VCS_INFO_get_data_git
;; * https://github.com/zsh-users/zsh/blob/2f2aa36/Misc/vcs_info-examples
;; * https://kitchingroup.cheme.cmu.edu/blog/2014/09/19/A-git-status-Emacs-modeline

(require 'dash)
(require 'cl-lib)

(defvar git-ml-debug nil
  "Whether to show debug messages.")

(defsubst git-ml--debug (format-string &rest args)
  (when git-ml-debug
    (apply #'message (concat "git-ml: " format-string) args)))

(defvar git-ml-check-git-action-p t
  "Should we check for the git action in progress?
This requires some synchronous file accesses that may pause Emacs
if the filesystem with the repo is very slow.")

(defun git-ml--get-git-action (git-dir)
  "Return the current git action in progress, or nil if there's none.
Example return values: \"rebase\", \"rebase-i\", \"cherry\".
GIT-DIR should be the path to the .git directory."
  ;; Logic from
  ;; <https://github.com/zsh-users/zsh/blob/2f2aa36/Functions/VCS_Info/Backends/VCS_INFO_get_data_git>.
  ;; I haven't found an async way to do this.
  (or
   (--some
    (let ((dir (expand-file-name it git-dir)))
      (when (file-directory-p dir)
        (or
         (and (file-regular-p (expand-file-name "rebasing" dir)) "rebase")
         (and (file-regular-p (expand-file-name "applying" dir)) "am")
         "am/rebase")))
    '("rebase-apply" "rebase" "../.dotest"))

   (--some
    (let ((file (expand-file-name it git-dir)))
      (when (file-regular-p file)
        "rebase-i"))
    '("rebase-merge/interactive" ".dotest-merge/interactive"))

   (--some
    (let ((dir (expand-file-name it git-dir)))
      (when (file-directory-p dir)
        "rebase-m"))
    '("rebase-merge" ".dotest-merge"))

   (and (file-regular-p (expand-file-name "MERGE_HEAD" git-dir)) "merge")

   (and (file-regular-p (expand-file-name "BISECT_LOG" git-dir)) "bisect")

   (and (file-regular-p (expand-file-name "CHERRY_PICK_HEAD" git-dir))
        (or (and (file-directory-p (expand-file-name "sequencer" git-dir))
                 "cherry-seq")
            "cherry"))

   (and (file-directory-p (expand-file-name "sequencer" git-dir))
        "cherry/revert")))

(defvar git-ml nil
  "Part of the modeline with git information.")
(make-variable-buffer-local 'git-ml)

;; Structs have to be defined before we try to `setf' their slots, otherwise
;; we'll get errors like `Symbol’s function definition is void: \(setf\
;; git-ml-result-action\)'.

(cl-defstruct (git-ml--state (:constructor git-ml--state-create)
                             (:copier nil))
  buffer
  process-dir
  remaining-processes)

(cl-defstruct (git-ml-result (:constructor git-ml-result-create)
                             (:copier nil))
  (action nil)
  (head nil)
  (oid nil)
  (upstream nil)
  (n-commits-ahead nil)
  (n-commits-behind nil)
  (n-files-staged 0)
  (n-files-unstaged 0)
  (n-files-unmerged 0)
  (n-files-untracked 0))

(defvar git-ml-render-function #'git-ml-render
  "Function to use to render the git-ml variable. It will be
called with the result struct, or nil if there was an error
getting git information. It should return a string or nil.")

(defun git-ml-render (result)
  (git-ml--debug "Rendering: %S" result)
  (when result
    (concat
     " "
     (when (git-ml-result-action result)
       (format "[%s] " (git-ml-result-action result)))
     (if (string= (git-ml-result-head result) "(detached)")
         (if (string= (git-ml-result-oid result) "(initial)")
             "(initial)"
           (substring (git-ml-result-oid result) 0 7))
       (git-ml-result-head result))
     (mapconcat
      (lambda (symbol-and-number)
        (let ((symbol (car symbol-and-number))
              (number (cdr symbol-and-number)))
          (when (not (memq number '(nil 0)))
            (concat " " symbol (number-to-string number)))))
      (list
       (cons "!" (git-ml-result-n-files-unstaged result))
       (cons "+" (git-ml-result-n-files-staged result))
       (cons "~" (git-ml-result-n-files-unmerged result))
       (cons "?" (git-ml-result-n-files-untracked result))
       (cons "↑" (git-ml-result-n-commits-ahead result))
       (cons "↓" (git-ml-result-n-commits-behind result)))
      ""))))

(defun git-ml--maybe-finish (state result)
  "If we've finished gathering information, set the modeline variable."
  (cl-assert (>= (git-ml--state-remaining-processes state) 0))
  (when (and (zerop (git-ml--state-remaining-processes state))
             (buffer-live-p (git-ml--state-buffer state)))
    (setf (buffer-local-value 'git-ml (git-ml--state-buffer state))
          (funcall git-ml-render-function result))
    (git-ml--debug
     "Rendered: %S"
     (buffer-local-value 'git-ml (git-ml--state-buffer state)))))

(defun git-ml--parse-git-status (buffer result)
  (with-current-buffer buffer
    (goto-char (point-min))
    (save-match-data
      (while (not (eobp))
        (git-ml--debug "git status line: %s"
                       (buffer-substring-no-properties
                        (point) (line-end-position)))
        (cond
         ;; Optional headers, e.g. `# branch.ab +0 -0'.
         ((looking-at "# \\([^ ]+\\) \\(.+\\)$")
          (let ((key (match-string-no-properties 1))
                (value (match-string-no-properties 2)))
            (cond
             ((string= key "branch.oid")
              (setf (git-ml-result-oid result) value))
             ((string= key "branch.head")
              (setf (git-ml-result-head result) value))
             ((string= key "branch.upstream")
              (setf (git-ml-result-upstream result) value))
             ((string= key "branch.ab")
              (if (string-match "^\\+\\([0-9]+\\) -\\([0-9]+\\)$" value)
                  (progn
                    (setf (git-ml-result-n-commits-ahead result)
                          (string-to-number (match-string-no-properties 1 value)))
                    (setf (git-ml-result-n-commits-behind result)
                          (string-to-number (match-string-no-properties 2 value))))
                (error "Can't parse value for branch.ab: %s" value))))))
         ;; Changes, e.g. `1 .M N... 100644 (...) git-ml.el'.
         ((looking-at "\\(?:1\\|2\\) \\(.\\)\\(.\\) ")
          (when (not (string= (match-string-no-properties 1) "."))
            (cl-incf (git-ml-result-n-files-staged result)))
          (when (not (string= (match-string-no-properties 2) "."))
            (cl-incf (git-ml-result-n-files-unstaged result))))
         ;; Unmerged files, e.g. `u UU N... 100644 (...) git-ml.el'.
         ((looking-at "u ")
          (cl-incf (git-ml-result-n-files-unmerged result)))
         ;; Untracked files, e.g. `? git-ml.el'.
         ((looking-at "\\? ")
          (cl-incf (git-ml-result-n-files-untracked result))))
        (forward-line)))))

(defun git-ml--status-sentinel (process msg)
  (when (and (eq (process-status process) 'exit)
             (zerop (process-exit-status process))
             (buffer-live-p (process-buffer process)))
    (let ((state (process-get process 'git-ml--state-struct))
          (result (process-get process 'git-ml--result-struct)))
      (git-ml--parse-git-status (process-buffer process) result)
      (kill-buffer (process-buffer process))
      (cl-decf (git-ml--state-remaining-processes state))
      (git-ml--maybe-finish state result))))

(defun git-ml--git-dir-sentinel (process msg)
  (when (and (eq (process-status process) 'exit)
             (zerop (process-exit-status process))
             (buffer-live-p (process-buffer process)))
    (let ((state (process-get process 'git-ml--state-struct))
          (result (process-get process 'git-ml--result-struct)))
      (with-current-buffer (process-buffer process)
        (goto-char (point-max))
        (when (save-match-data (looking-back "\n"))
          (delete-char -1))
        (let* ((git-dir (buffer-substring-no-properties (point-min) (point-max)))
               (abs-git-dir (expand-file-name
                             git-dir (git-ml--state-process-dir state)))
               (action (git-ml--get-git-action abs-git-dir)))
          (setf (git-ml-result-action result) action))
        (kill-buffer))
      (cl-decf (git-ml--state-remaining-processes state))
      (git-ml--maybe-finish state result))))

(defun git-ml-refresh ()
  "Refresh git state of the current buffer."
  (interactive)
  (let* ((default-directory (if (buffer-file-name)
                                (file-name-directory (buffer-file-name))
                              default-directory))
         (state-struct
          (git-ml--state-create
           :buffer (current-buffer)
           :process-dir default-directory
           :remaining-processes (if git-ml-check-git-action-p 2 1)))
         (result-struct (git-ml-result-create))
         (status-process
          (make-process :name "git status for modeline"
                        :buffer " *git status for modeline*"
                        ;; Ignore dirty submodules because we wouldn't do anything with them.
                        :command '("git" "status" "--porcelain=2" "--branch"
                                   "--ignore-submodules=dirty")
                        :connection-type 'pipe
                        :sentinel #'git-ml--status-sentinel
                        :noquery t))
         (git-dir-process
          (when git-ml-check-git-action-p
            (make-process :name "git rev-parse for modeline"
                          :buffer " *git rev-parse for modeline*"
                          :command '("git" "rev-parse" "--git-dir")
                          :connection-type 'pipe
                          :sentinel #'git-ml--git-dir-sentinel
                          :noquery t))))
    ;; Will this always execute before a sentinel runs? I think so, but not sure.
    (dolist (process (list status-process git-dir-process))
      (when process
        (process-put process 'git-ml--state-struct state-struct)
        (process-put process 'git-ml--result-struct result-struct)))))

(defun git-ml-activate ()
  (interactive)
  (add-hook 'find-file-hook #'git-ml-refresh)
  (add-hook 'after-save-hook #'git-ml-refresh))

(provide 'git-ml)

(git-ml-activate)

#+end_src

*** Templates and Snippets
**** Package: yasnippet

Can use either hydra menu or type a snippet abbreviation and press TAB to expand

#+begin_src emacs-lisp

(use-package yasnippet-snippets
  :defer t)

(use-package yasnippet
  :after yasnippet-snippets
  :config
  (yas-global-mode 1)
  :hook (makefile-gmake-mode . (lambda () (yas-minor-mode -1))))

(use-package ivy-yasnippet
  :after yasnippet
  :commands ivy-yasnippet)

#+end_src

*** Multiple Cursors
**** Package: multiple-cursors

Use multiple cursors on swiper candidates with the corresponding swiper keybinding.

#+begin_src emacs-lisp

(use-package multiple-cursors
  :init
  (custom-set-variables `(mc/always-run-for-all ,t))
  :config
  (define-key mc/keymap [remap keyboard-quit] 'mc/keyboard-quit)
  (define-key rectangular-region-mode-map [remap keyboard-quit] 'rrm/keyboard-quit)
  ;; use C-7 to add a cursor to every swiper selection
  (add-to-list 'mc/cmds-to-run-once 'swiper-mc)
  (global-unset-key (kbd "C-<down-mouse-1>"))
  :bind
  ("C-<mouse-1>" . mc/add-cursor-on-click)
  (:map wakib-keys-overriding-map
        ("M-S" . set-rectangular-region-anchor))
  (:map mc/keymap
        ("M-S-<down>" . mc/mark-next-like-this)
        ("M-S-<up>" . mc/mark-previous-like-this)))

#+end_src

*** Presentations
**** Package: ox-reveal

Write in Org mode and export to HTML with reveal.js

#+begin_src emacs-lisp

(use-package ox-reveal
  :ensure-system-package (decktape)
  :commands (my/export-reveal-presentation-to-pdf org-reveal-export-to-html)
  :init
  (defun my/export-reveal-presentation-to-pdf ()
    "Create a pdf from an org file using a reveal.js package.
Take the name of the currently open buffer and search for a file with
the same name and an html extension. Then convert the Reveal html file
to a pdf, with the decktape utility."
    (interactive)
    (let* ((file-name (file-name-sans-extension (buffer-name)))
           (html-file-name (concat file-name ".html"))
           (pdf-file-name (concat file-name ".pdf")))
      (if (not (file-exists-p html-file-name))
          (error (concat "Reveal HTML file " html-file-name " not found"))
        (async-shell-command
         (concat "decktape reveal --size='2048x1536' " html-file-name " " pdf-file-name))
        (message (concat pdf-file-name " successfully created")))))

  :custom
  ;; (setq org-reveal-root      "~/.reveal/reveal.js")
  (org-reveal-root           "https://cdn.jsdelivr.net/npm/reveal.js")
  (org-reveal-title-slide    "<h1>%t</h1><h3>%s</h3>")  ;; set content of initial slide: %t - Title, %s - subtitle
  )

#+end_src

#+begin_src emacs-lisp

;; necessary to highlight source code
(use-package htmlize)

#+end_src

**** Notes and basic usage

- Using *reveal*

To export to pdf, open the HTML file in a browser and add the query string =print-pdf= to the end of the URL.

As an example, for a URL like this:
=file:///home/user/Documents/presentation.html=

The desired URL would be:
=file:///home/user/Documents/presentation.html?print-pdf=

Then use the browser to export the page as a PDF.
Follow the directions at https://revealjs.com/pdf-export/


- Using *decktape*

Another simpler option is to use the decktape cli utility.

Assuming you have it installed, run:
decktape reveal <my-file.html> <output>

*** Move Text
**** Package: drag-stuff

Moving text both horizontally and vertically.
I use the M + arrow keys for this. Since this interferes with org-mode, we use the default org-mode keybinds when the cursor is in an org-heading.

This package is only used to move lines up and down. Moving left and right is implemented with default emacs functionality.

#+begin_src emacs-lisp

(use-package drag-stuff
  :config

  ;; Move up and down
  (defun my/meta-up-org-heading-detect ()
    "Executes a different function if the cursor is in a org heading.
Otherwise, just execute the normal behaviour"
    (interactive)
    (if (and (equal major-mode 'org-mode) (org-at-heading-p))
        (org-move-subtree-up)
      (call-interactively 'drag-stuff-up)))

  (defun my/meta-down-org-heading-detect ()
    "Executes a different function if the cursor is in a org heading.
Otherwise, just execute the normal behaviour"
    (interactive)
    (if (and (equal major-mode 'org-mode) (org-at-heading-p))
        (org-move-subtree-down)
      (call-interactively 'drag-stuff-down)))

  ;; Move left and right
  (defun my/meta-right-org-heading-detect ()
    "Executes a different function if the cursor is in a org heading.
Otherwise, just execute the normal behaviour"
    (interactive)
    (if (and (equal major-mode 'org-mode) (org-at-heading-p))
        (org-do-demote)
      (my/tab-region (my/get-buffer-indentation-size))))

  (defun my/meta-left-org-heading-detect ()
    "Executes a different function if the cursor is in a org heading.
Otherwise, just execute the normal behaviour"
    (interactive)
    (if (and (equal major-mode 'org-mode) (org-at-heading-p))
        (org-do-promote)
      (my/untab-region (my/get-buffer-indentation-size))))

  :bind
  (:map wakib-keys-overriding-map
        ("M-<left>" . my/meta-left-org-heading-detect)
        ("M-<right>" . my/meta-right-org-heading-detect)
        ("M-<up>" . my/meta-up-org-heading-detect)
        ("M-<down>" . my/meta-down-org-heading-detect)))

#+end_src

*** Hydras
**** Package: hydra

#+begin_src emacs-lisp

(use-package hydra)

#+end_src

**** Package: hydra-posframe

#+begin_src emacs-lisp

(use-package hydra-posframe
  :hook (after-init . hydra-posframe-mode)
  :custom
  ;; copy the border values from 'ivy-posframe-parameters'
  (hydra-posframe-parameters'((min-height            . 14)
                              (min-width             . 50)
                              (left-fringe           . 2)
                              (right-fringe          . 2)
                              (internal-border-width . 2)))
  :straight
  (hydra-posframe :type git :host github :repo "Ladicle/hydra-posframe"
                  :fork (:host github :repo "jerrypnz/hydra-posframe")))

#+end_src

**** Package: major-mode-hydra

show a different main hydra, depending on major mode

#+begin_src emacs-lisp

(use-package major-mode-hydra)

#+end_src

**** Hydra: bookmarks

#+begin_src emacs-lisp

(pretty-hydra-define hydra-bookmarks
  (:color teal :quit-key "q" :title "Bookmarks Hydra")
  ("Bookmarks"
   (("o" counsel-bookmark "open bookmark")
    ("c" bookmark-set "create bookmark from current buffer")
    ("r" bookmark-rename "rename bookmark")
    ("d" bookmark-remove "delete bookmark"))
   ))

#+end_src

**** Hydra: buffer

#+begin_src emacs-lisp

(pretty-hydra-define hydra-buffer
  (:color teal :quit-key "q" :title "Buffer/Workspace Hydra")
  ("Save"
   (("s" save-some-buffers "Save all buffers"))
   "Switch Buffer"
   (("b" bufler-list "Show all buffers and workspaces")
    ("Bw" bufler-switch-buffer "Switch buffer (current workspace)")
    ("Ba" my/bufler-switch-buffer-C-u "Switch buffer (all workspaces)"))
   "Switch Workspace"
   (("w" bufler-workspace-frame-set "Switch current workspace"))
   "TODO and similar keywords"
   (("tp" hl-todo-previous "Jump to previous TODO keyword")
    ("tn" hl-todo-next "Jump to next TODO keyword")
    ("to" hl-todo-occur "Find all TODO keywords"))
   ))

#+end_src

**** Hydra: code

#+begin_src emacs-lisp

(pretty-hydra-define hydra-code
  (:color teal :quit-key "q" :title "Code Hydra")
  ("Function"
   (("c" compile "Compile current buffer program")
    ("d" find-function-at-point "Jump to Declaration (symbol at point)")
    ("r" xref-find-references "Show Reference List (symbol at point)"))
   "Syntax Checker"
   (("x" flycheck-list-errors "List errors"))
   ))

#+end_src

**** Hydra: compilation-mode

#+begin_src emacs-lisp

(major-mode-hydra-define compilation-mode
  (:color teal :quit-key "q" :title "Compilation hydra" :separator "-")
  ("Kill"
   (("k" kill-compilation "kill compilation process"))
   ))

#+end_src

**** Hydra: diff

#+begin_src emacs-lisp

(pretty-hydra-define hydra-diff
  (:color teal :quit-key "q" :title "Diff Hydra")
  ("Compare Files"
   (("c" diff "Simple diff two files")
    ("C" ediff "Ediff two files"))
   "Compare Regions"
   (("r" ediff-regions-wordwise "Ediff wordwise")
    ("R" ediff-regions-linewise "Ediff linewise"))
   ))

#+end_src

**** Hydra: dockerfile-mode

#+begin_src emacs-lisp

(major-mode-hydra-define dockerfile-mode
  (:color teal :quit-key "q" :title "Dockerfile hydra" :separator "-")
  ("Build"
   (("b" dockerfile-build-buffer "build dockerfile")
    ("B" dockerfile-build-no-cache-buffer "build dockerfile with no cache"))
   ))

#+end_src

**** Hydra: emacs-lisp-mode

#+begin_src emacs-lisp

(major-mode-hydra-define emacs-lisp-mode
  (:color teal :quit-key "q" :title "Emacs Lisp hydra" :separator "-")
  ("Eval sexp before point"
   (("e" eval-last-sexp "Eval and print value in the echo area")
    ("b" eval-print-last-sexp "Eval and print value into current buffer")
    ("p" pp-eval-last-sexp "Eval and pretty print value in new buffer"))
   ))

#+end_src

**** Hydra: eval                                                :notangle:

#+begin_src emacs-lisp

(pretty-hydra-define hydra-eval
  (:color teal :quit-key "q" :title "Eval Hydra")
  ("Evaluate "
   (("e" eval-expression "Expression"))
   ))

#+end_src

**** Hydra: file

#+begin_src emacs-lisp

(pretty-hydra-define hydra-file
  (:color teal :quit-key "q" :title "Files Hydra")
  ("Filename"
   (("y" my/show-buffer-name "Yank filename")
    ("Y" my/show-buffer-file-name "Yank filename with full path"))
   "Current File"
   (("s" save-buffer "Save")
    ("S" write-file "Copy/Save as...")
    ("R" my/rename-current-buffer-file "Rename/Move")
    ("u" sudo-edit "Sudo open")
    ("d" my/delete-file-and-buffer "Delete")
    ("x" my/make-file-executable "Make .sh executable"))
   "Other Files"
   (("f" counsel-find-file "Open a file")
    ("r" counsel-recentf "Open recent file")
    ("U" sudo-edit-find-file "Sudo open a file")
    ("D" delete-file "Delete a file")
    ("z" fzf-current-directory "Open a File using fzf")
    ("Z" fzf-directory "Open a File in another directory using fzf"))
   ))

#+end_src

**** Hydra: help

#+begin_src emacs-lisp

(pretty-hydra-define hydra-help
  (:color teal :quit-key "q" :title "Help Hydra")
  ("Describe global"
   (("f" counsel-describe-function "Function")
    ("v" counsel-describe-variable "Variable")
    ("F" counsel-faces "Face")
    ("k" describe-key "Key")
    ("o" counsel-describe-symbol "Symbol (anything)"))
   "Current buffer"
   (("b" counsel-descbinds "Show all Keys and Bindings")
    ("m" describe-mode "Show Major and Minor modes"))
   "Customize"
   (("g" customize-group "Customize Group"))
   ))

#+end_src

**** Hydra: indentation

#+begin_src emacs-lisp

(pretty-hydra-define hydra-indentation
  (:color teal :quit-key "q" :title "Indentation Hydra")
  ("Switch"
   (("t" my/switch-indentation-use-tabs "indent with tabs")
    ("s" my/switch-indentation-use-spaces "indent with spaces"))
   "Convert"
   (("cT" my/tabify-whole-buffer "convert indentation (in whole buffer) to tabs")
    ("cS" my/untabify-whole-buffer "convert indentation (in whole buffer) to spaces")
    ("ct" tabify "convert indentation (in active region) to tabs")
    ("cs" untabify "convert indentation (in active region) to spaces"))
   "Resize"
   (("w" my/set-buffer-indentation-size "set indentation width"))
   ))

#+end_src

**** Hydra: insert

#+begin_src emacs-lisp

(pretty-hydra-define hydra-insert
  (:color teal :quit-key "q" :title "Insert Hydra")
  ("Unicode"
   (("u" counsel-unicode-char "insert unicode character"))
   "Clipboard"
   (("y" counsel-yank-pop "select from clipboard history"))
   "Snippet"
   (("s" ivy-yasnippet "insert snippet"))
   "Todo"
   (("t" hl-todo-insert "insert comment with TODO or similar keyword"))
   ))

#+end_src

**** Hydra: latex-mode

#+begin_src emacs-lisp

(major-mode-hydra-define latex-mode
  (:color teal :quit-key "q" :title "Latex hydra" :separator "-")
  ("Compile"
   (("c" TeX-command-run-all "compile with Emacs")
    ("m" my/latex-compile-makefile-and-open-pdf "compile with Makefile"))
   ))

#+end_src

**** Hydra: markdown-mode

#+begin_src emacs-lisp

(major-mode-hydra-define markdown-mode
  (:color teal :quit-key "q" :title "Markdown hydra" :separator "-")
  ("Preview"
   (("p" vmd-mode "live preview"))
   ))

#+end_src

**** Hydra: open

#+begin_src emacs-lisp

(pretty-hydra-define hydra-open
  (:color teal :quit-key "q"  :title "Open/Utilities Hydra")
  ("Special Buffer"
   (("D" my/open-dashboard "open dashboard buffer")
    ("s" my/open-scratch-buffer "open scratch buffer")
    ("a" my/org-agenda "open agenda")
    ("A" org-agenda "open agenda menu")
    ("d" dired "open directory with dired")
    ("e" eshell "open emacs shell"))
   "Special File"
   (("p" my/open-init-file "open private Emacs config"))
   "Org Directory"
   (("o" my/open-file-from-org-dir "open file from org directory"))
   "URL"
   (("u" browse-url-xdg-open "open URL in browser"))
   ))

#+end_src

**** Hydra: org-mode

#+begin_src emacs-lisp

(major-mode-hydra-define org-mode
  (:color teal :quit-key "q" :title "Org hydra" :separator "-")
  ("General"
   (("C" my/org-content-with-argument "show content up to level N")
    ("g" counsel-org-goto "goto org heading")
    ("e" org-export-dispatch "export dispatch")
    ("i" org-insert-link "insert/edit link")
    ("P" org-emphasize "insert or change text emphasis"))
   "Org Latex"
   (("ll" org-latex-export-to-latex "export to Latex file")
    ("lc" org-latex-export-to-pdf "compile with Emacs")
    ("lm" my/latex-compile-makefile-and-open-pdf "compile with Makefile"))
   "Reveal.js"
   (("rr" org-reveal-export-to-html "export to HTML file")
    ("rp" my/export-reveal-presentation-to-pdf "convert HTML file to PDF"))
   "Heading"
   (("s" org-sort "sort subtree")
    ("x" org-cut-subtree "cut subtree")
    ("c" org-copy-subtree "copy subtree")
    ("v" org-paste-subtree "paste subtree")
    ("m" org-refile "move subtree"))
   "Timestamp"
   (("tt" org-time-stamp "insert timestamp")
    ("ts" org-schedule "insert \"scheduled\" string")
    ("td" org-deadline "insert \"deadline\" string"))
   ))

#+end_src

**** Hydra: package manager

#+begin_src emacs-lisp

(pretty-hydra-define hydra-packages
  (:color teal :quit-key "q" :title "Packages Hydra")
  ("Package Manager"
   (("i" straight-use-package "install package (for this session only)")
    ("u" straight-rebuild-all "update all packages"))
   ))

#+end_src

**** Hydra: quit/session

#+begin_src emacs-lisp

(pretty-hydra-define hydra-quit
  (:color teal :quit-key "q" :title "Quit/Session Hydra")
  ("Emacs"
   (("Q" my/kill-emacs "Quit Emacs")
    ("r" restart-emacs "Restart emacs"))
   "Session"
   (("l" my/desktop-enable "Quick load last session")
    ;; ("L" desktop-read "Restore session from file")
    ("s" desktop-save-in-desktop-dir "Quick save current session")
    ;; ("S" desktop-save "Save session to file")
    )
   ))

#+end_src

**** Hydra: search

#+begin_src emacs-lisp

(pretty-hydra-define hydra-search
  (:color teal :quit-key "q" :title "Search Hydra")
  ("String in buffer contents (regex)"
   (("b" swiper "search in current buffer")
    ("d" search-everything-regexp "search in directory files"))
   "String in filenames (glob)"
   (("f" fd-dired "locate files"))
   "Project"
   (("p" search-everything-regexp-project "search text")
    ("P" counsel-projectile-rg "search and jump to text")
    ("r" projectile-replace "replace text (literal)"))
   ))

#+end_src

**** Hydra: spellcheck

#+begin_src emacs-lisp

(pretty-hydra-define hydra-spellcheck
  (:color teal :quit-key "q" :title "Spellcheck Hydra")
  ("Dictionary"
   (("d" ispell-change-dictionary "change dictionary language"))
   ))

#+end_src

**** Hydra: toggles

#+begin_src emacs-lisp

(pretty-hydra-define hydra-toggles
  (:color amaranth :quit-key "q" :title "Toggles Hydra")
  ("Highlight"
   (("L" global-hl-line-mode "current line (global)" :toggle t)
    ("h" hl-todo-mode "hl-todo keywords" :toggle t)
    ;;("s" symbol-overlay-mode "symbol" :toggle t)
    ;;("x" highlight-sexp-mode "sexp" :toggle t)
    ("P" show-paren-mode "matching parens" :toggle t)
    ("r" rainbow-mode "rgb color codes" :toggle t)
    ("b" unsaved-buffer-changes-mode "unsaved buffer changes" :toggle t))
   "Code"
   (("l" flycheck-mode "linter" :toggle t)
    ("s" flyspell-mode "spell checker" :toggle t)
    ("c" global-company-mode "code completion" :toggle t)
    ("p" electric-pair-mode "auto close parens" :toggle t)
    ("g" diff-hl-mode "git gutter" :toggle t)
    ("S" yas-global-mode "snippets" :toggle t))
   "UI Elements"
   (("e" dired-sidebar-toggle-sidebar "file explorer sidebar")
    ("t" global-tab-line-mode "tab-line" :toggle t)
    ("T" global-blank-tab-line-mode "blank tab-line" :toggle t)
    ("m" hide-mode-line-mode "modeline" :toggle t)
    ("M" toggle-menu-bar "menu bar")
    ("n" display-line-numbers-mode "line numbers" :toggle t)
    ("N" global-display-line-numbers-mode "line numbers (global)" :toggle t)
    ("o" imenu-list-smart-toggle "outline sidebar"))
   "Misc"
   (("O" global-org-hide-emphasis-mode "hide org emphasis markers" :toggle t)
    ;; ("G" golden-ratio-mode "resize windows with golden ratio" :toggle t)
    ("w" line-wrap-mode "line wrap" :toggle t))
   "Debug"
   (("D" toggle-debug-on-error "debug on error" :toggle (default-value 'debug-on-error))
    ("X" toggle-debug-on-quit "debug on quit" :toggle (default-value 'debug-on-quit)))
   ))

#+end_src

**** Hydra: version control

#+begin_src emacs-lisp

(pretty-hydra-define hydra-git
  (:color teal :quit-key "q" :title "Git Hydra")
  ("Magit"
   (("g" magit-status "show git status")
    ("l" magit-log "git log")
    ("D" magit-diff "git diff")
    ("b" magit-blame "git blame"))
   "Hunk"
   (("p" diff-hl-previous-hunk "previous")
    ("n" diff-hl-next-hunk "next")
    ("r" diff-hl-revert-hunk "revert")
    ("d" diff-hl-diff-goto-hunk "show hunk diff"))
   ))

#+end_src

**** Hydra: window

#+begin_src emacs-lisp

(pretty-hydra-define hydra-window
  (:color teal :quit-key "q" :title "Window Hydra")
  ("Create"
   (("h" my/split-window-horizontally-and-follow "New horizontal split")
    ("v" my/split-window-vertically-and-follow "New vertical split"))
   "Delete"
   (("w" delete-other-windows "Other windows")
    ("d" delete-window "Current window"))
   "Layout"
   (("l" rotate-layout "Cycle layout")
    ("r" rotate-window "Rotate windows"))
   "Window Size"
   (("M" maximize-window "Maximize")
    ("m" minimize-window "Minimize")
    ("b" balance-windows "Balance"))
   "Window Selection"
   (("s" other-window "Select other window")
    ("c" switch-window "Cycle open windows"))
   ))

#+end_src

**** Font fix

Depending on the font, the line below the hydra title can be too long or too short.
Here, we are replacing the font, only targeting the unicode symbol used to draw the line.

#+begin_src emacs-lisp

(set-fontset-font "fontset-default"
                  '(#x2500 . #x250F) (font-spec :name "SourceCodePro"))

#+end_src

**** Notes and basic usage

The color of a hydra is used to define how a hydra exits after executing.
The default color is red.

Behavior by color:

| color    | toggle                     |
|----------+----------------------------|
| red      |                            |
| blue     | :exit t                    |
| amaranth | :foreign-keys warn         |
| teal     | :foreign-keys warn :exit t |
| pink     | :foreign-keys run          |

As for naming conventions inside a hydra:
  - section names should be objects
  - section entries should be actions (performed on the respective object)

To see an example of hydras from a popular Emacs distribution:
# https://github.com/hlissner/doom-emacs/blob/develop/modules/config/default/+evil-bindings.el

*** PDF Viewer
**** Package: pdf-tools

*ensure-system-package* looks for binaries and is agnostic of package managers.

For Arch, the respective necessary packages are:
  - base-devel
  - libpng
  - zlib
  - poppler-glib.

#+begin_src emacs-lisp

(use-package pdf-tools
  :commands (pdf-occur-global-minor-mode)
  :ensure-system-package
  (("/usr/lib/libpoppler-glib.so" . libpng)
   ("/usr/lib/libz.so"            . zlib)
   ("/usr/lib/libpng.so"          . poppler-glib))
  :config
  (pdf-tools-install :no-query :no-dependencies)
  (setq-default pdf-view-display-size 'fit-page)
  :custom
  (pdf-annot-activate-created-annotations t "automatically annotate highlights")
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :bind
  (:map pdf-view-mode-map
        ("C-f" . isearch-forward)))

#+end_src

**** Minor mode: fix M-<pg up/down> behaviour                   :notangle:

This needs to be added to the end of any org file that is being used to create a LaTeX pdf.

#+begin_example
# Local Variables:
# eval: (my/scroll-other-window-pdf-tools-mode 1)
# End:
#+end_example

#+begin_src emacs-lisp

(defun my/scroll-other-window-down ()
  "Scroll other window down, with support for pdf-view-mode."
  (interactive)
  (let* ((wind (other-window-for-scrolling))
         (mode (with-selected-window wind major-mode)))
    (if (eq mode 'pdf-view-mode)
        (with-selected-window wind
      (pdf-view-next-line-or-next-page 2))
      (scroll-other-window 2))))

(defun my/scroll-other-window ()
  "Scroll other window up, with support for pdf-view-mode."
  (interactive)
  (let* ((wind (other-window-for-scrolling))
         (mode (with-selected-window wind major-mode)))
    (if (eq mode 'pdf-view-mode)
    (with-selected-window wind
      (progn
        (pdf-view-previous-line-or-previous-page 2)
        (other-window 1)))
    (scroll-other-window-down 2))))

#+end_src

#+begin_src emacs-lisp
;; my/scroll-other-window-pdf-tools-mode.el
;; Temporary minor mode
;; Main use is to enable it only in specific buffers to achieve the goal of buffer-specific keymaps

(defvar my/scroll-other-window-pdf-tools-mode-map (make-sparse-keymap)
  "Keymap while my/scroll-other-window-pdf-tools-mode is active.")

;;;###autoload
(define-minor-mode my/scroll-other-window-pdf-tools-mode
  "A temporary minor mode to be activated only specific to a buffer."
  nil
  :lighter " Temp"
  my/scroll-other-window-pdf-tools-mode-map)

(define-key my/scroll-other-window-pdf-tools-mode-map (kbd "M-<next>") 'my/scroll-other-window-down)
(define-key my/scroll-other-window-pdf-tools-mode-map (kbd "M-<prior>") 'my/scroll-other-window)

#+end_src

*** Code Linter
**** Package: flycheck

Code syntax checking.

# Not sure, but this might have to load after flyspell package.
# also, see "flycheck-select-checker" function

This is configured to use the margin, instead of the default fringe.

#+begin_src emacs-lisp

(use-package flycheck
  :config
  (defun my/flycheck-use-margin-toggle ()
    (if flycheck-mode
        (progn
          (setq flycheck-indication-mode 'left-margin
                left-margin-width 1)
          (flycheck-refresh-fringes-and-margins))
      (progn
        (setq left-margin-width 0)
        (flycheck-refresh-fringes-and-margins))))

  :hook
  ((prog-mode . flycheck-mode)
   (flycheck-mode . my/flycheck-use-margin-toggle)))

#+end_src

*** Spacemacs-esque menu
**** Package: general

This should be one of the last packages to be loaded.
The other packages first have to create their hydras and only after that should we create a menu using those hydras.

Normally, when an entry is a sub-menu, it has a different color and a plus sign. Since my menus are hydras, it doesn't count as a sub-menu for general.

#+begin_src emacs-lisp

(use-package general
  :config
  (unbind-key "M-SPC")

  (general-define-key
   :prefix "M-SPC"
   "\'" '(my/open-external-terminal-here :which-key "open external terminal")
   "," '(ivy-resume :which-key "resume last search")
   "." '(repeat :which-key "repeat last command")
   ":" '(eval-expression :which-key "eval expression"))

  (general-define-key
   :prefix "M-SPC"
   "b" '(hydra-buffer/body :which-key "+buffer")
   "B" '(hydra-bookmarks/body :which-key "+bookmarks")
   "c" '(hydra-code/body :which-key "+code")
   "d" '(hydra-diff/body :which-key "+diff")
   "f" '(hydra-file/body :which-key "+file")
   "g" '(hydra-git/body :which-key "+git")
   "h" '(hydra-help/body :which-key "+help")
   "i" '(hydra-insert/body :which-key "+insert")
   "I" '(hydra-indentation/body :which-key "+indentation")
   "m" '(major-mode-hydra :which-key "+major-mode")
   "o" '(hydra-open/body :which-key "+open")
   "p" '(projectile-hydra/body :which-key "+project")
   "P" '(hydra-packages/body :which-key "+packages")
   "q" '(hydra-quit/body :which-key "+quit/session")
   "s" '(hydra-search/body :which-key "+search")
   "S" '(hydra-spellcheck/body :which-key "+spellcheck")
   "t" '(hydra-toggles/body :which-key "+toggles")
   "w" '(hydra-window/body :which-key "+window")))

#+end_src

*** Outline sidebar
**** Package: imenu-list

Shows a sidebar with a list of all symbols (methods, variables, etc.) in current buffer.
Allows searching and jumping to these symbols.

#+begin_src emacs-lisp

(use-package imenu-list
  :commands (imenu-list-smart-toggle)
  :custom
  (imenu-list-focus-after-activation t)
  (imenu-list-auto-resize            nil)
  (imenu-list-size                   70)
  (imenu-list-after-jump-hook        nil)
  (imenu-list-position               'right)
  :hook
  (imenu-list-after-jump . recenter-top-bottom)
  (imenu-list-major-mode . (lambda () (display-line-numbers-mode -1)))
  (imenu-list-major-mode . hide-mode-line-mode))

#+end_src

*** Other additions
**** Package: comment-dwim-2

#+begin_src emacs-lisp

(use-package comment-dwim-2
  :config
  (defun my/comment-dwim-2 (arg)
    (interactive "*P")
    (if (use-region-p)
        (my/extend-region-to-whole-lines))
    (if (and (equal major-mode 'org-mode) (org-at-heading-p))
        (org-comment-dwim-2 arg)
      (comment-dwim-2 arg))))

#+end_src

**** Package: undo-tree

Change undo/redo behaviour

#+begin_src emacs-lisp

(use-package undo-tree
  :defer 1
  :after comment-dwim-2
  :config
  (global-undo-tree-mode)
  :bind
  (:map wakib-keys-overriding-map
        ("C-z" . undo-tree-undo)
        ("C-y" . undo-tree-redo))
  (:map undo-tree-map
        ("C-/" . my/comment-dwim-2)))

;; C-/ is defined here because it conflicts with an existing bindin in this package

#+end_src

**** Package: sudo-edit

Edit files with elevated permissions

#+begin_src emacs-lisp

(use-package sudo-edit
  :commands (sudo-edit sudo-edit-find-file sudo-edit-indicator-mode))

#+end_src

**** Package: bind-key

 Key Rebinding utility. Will be used in the keybinds section

#+begin_src emacs-lisp

(use-package bind-key)

#+end_src

**** Package: which-key

Display available keybindings in popup after a prefix key is pressed

#+begin_src emacs-lisp

(use-package which-key
  :config
  (set-face-attribute 'which-key-local-map-description-face nil :weight 'bold)
  (which-key-mode))

#+end_src

**** Package: recentf

Save a list of most recently edited files.
We exclude elpa folder from recent files to prevent autoload files filling it up.

#+begin_src emacs-lisp

(use-package recentf
  :config
  (recentf-mode)
  (setq recentf-max-saved-items 100
        recentf-exclude '("COMMIT_EDITMSG\\'"
                          "[/\\]elpa/\\.*"
                          "[/\\]var/\\.*")))

#+end_src

**** Package: restart-emacs

Add an easy way to restart emacs

#+begin_src emacs-lisp

(use-package restart-emacs
  :commands (restart-emacs))

#+end_src

**** Package: expand-region

Expand region in logical increments.

#+begin_src emacs-lisp

(use-package expand-region
  :bind
  ("M-A" . er/expand-region))

#+end_src

**** Package: switch-window

#+begin_src emacs-lisp

(use-package switch-window
  :bind
  (:map wakib-keys-overriding-map
        ("M-H" . switch-window)))    ;; for some reason writing it as M-S-h doesn't work

#+end_src

**** Package: avy

Quickly go to any character on screen.
Can also be used to jump to word, line, symbol, etc.

#+begin_src emacs-lisp

(use-package avy
  :bind
  ("M-m" . avy-goto-char))

#+end_src

**** Package: ibuffer-vc                                        :notangle:

#+begin_src emacs-lisp

(use-package ibuffer-vc)

#+end_src

**** Package: symbolword-mode                                   :notangle:

#+begin_src emacs-lisp

(use-package symbolword-mode
  :init
  (symbolword-mode 1))

#+end_src

**** Package: whole-line-or-region

cut/copy whole line or region

when C-x or C-c are pressed with no active selection, cut/copy the line instead
default behaviour is to do the operation between the cursor and the mark, which is hidden

#+begin_src emacs-lisp

(use-package whole-line-or-region
  :config
  (defun my/whole-line-or-region-delete-region (prefix)
    (interactive "*p")
    (if (use-region-p)
        (my/extend-region-to-whole-lines))
    (whole-line-or-region-delete-region prefix))

  :bind
  (:map wakib-keys-overriding-map
        ("C-c" . whole-line-or-region-kill-ring-save)
        ("C-x" . whole-line-or-region-kill-region)
        ("C-k" . my/whole-line-or-region-delete-region))

  :hook
  (makefile-mode . (lambda () (bind-key "C-c" 'whole-line-or-region-kill-ring-save makefile-mode-map))))

;; Comment code lines, command reacts based on the major mode.
;; (bind-key "C-«" 'whole-line-or-region-comment-dwim wakib-keys-overriding-map)

#+end_src

**** Package: ssh-agency

Use this so magit can actually access the host system's ssh keys.

#+begin_src emacs-lisp

(use-package ssh-agency)

#+end_src

**** Package: ansi-color

mostly helps by adding support for terminal colors.

Deals with terminal escape codes in compilation-mode.
This should make compilation buffers handle ANSI escape sequences instead of displaying them as raw strings.

#+begin_src emacs-lisp

(use-package ansi-color
  :config
  (setq compilation-scroll-output t) ;; the compilation buffer always scrolls to follow output as it comes in

  (defun my/ansi-colorize-buffer ()
    (let ((buffer-read-only nil))
      (ansi-color-apply-on-region (point-min) (point-max))))

  :hook (compilation-filter . my/ansi-colorize-buffer))

#+end_src

**** Package: yascroll

Show a buffer position indicator on the right fringe

#+begin_src emacs-lisp

(use-package yascroll
  :config
  (global-yascroll-bar-mode 1))

#+end_src

**** Package: annotate                                          :notangle:

#+begin_src emacs-lisp

(use-package annotate
  :hook
  (org-mode . annotate-mode)
  (save-buffer . annotate-save-annotations))

#+end_src

**** Package: modern-fringes

Replace the default fringe icons with more modern looking ones

#+begin_src emacs-lisp

(use-package modern-fringes
  :config
  (modern-fringes-mode 1))

#+end_src

**** Package: scroll-on-jump                                    :notangle:

#+begin_src emacs-lisp

(use-package scroll-on-jump
  :config
  (setq scroll-on-jump-duration 0.6)
  :straight
  (scroll-on-jump
    :type git
    :host gitlab
    :repo "ideasman42/emacs-scroll-on-jump")
  :bind
  ("<prior>" . (scroll-on-jump-interactive 'scroll-down-command))
  ("<next>" . (scroll-on-jump-interactive 'scroll-up-command)))

#+end_src

**** Package: helpful

Better formatting for help buffers

#+begin_src emacs-lisp

(use-package helpful
  :commands helpful-mode
  :config
  (setq counsel-describe-function-function #'helpful-callable
        counsel-describe-variable-function #'helpful-variable))

#+end_src

**** Package: golden-ratio                                      :notangle:

This doesnt work well with which-key
https://github.com/roman/golden-ratio.el/issues/82

#+begin_src emacs-lisp

(use-package golden-ratio
  :config
  (add-to-list 'golden-ratio-exclude-buffer-names " *which-key*")
  (golden-ratio-mode t))

#+end_src

**** Package: shackle

rules for popup windows and window splits.

By default, always focus new windows.

#+begin_src emacs-lisp

(use-package shackle
  :init
  (setq shackle-default-alignment    'right
        shackle-default-rule         nil    ;; '(:select t)
        shackle-rules                '((flycheck-error-message-mode :noselect t)
                                       (magit-diff-mode :noselect t)
                                       (help-mode :select t)
                                       (rg-mode :select t)))
  :config
  (shackle-mode 1))

#+end_src

**** Package: fd-dired

#+begin_src emacs-lisp

(use-package fd-dired
  :ensure-system-package (fd)
  :commands fd-dired)

#+end_src

**** Package: fzf

note:
do not hide project files in .gitignore
use ~/.config/fd/ignore to ignore files

face used in fzf prompt is from term-mode.

#+begin_src emacs-lisp

(use-package fzf
  :ensure-system-package (fd fzf)
  :init
  (defvar my/fzf-command-default "fd --type 'file' --hidden --ignore-case --no-ignore-vcs --exclude '.git/*/*'")
  (setenv "FZF_DEFAULT_COMMAND" my/fzf-command-default)
  :config
  (defun fzf-current-directory ()
    "Starts an fzf session in the current directory."
    (interactive)
    (let ((path default-directory))
      (fzf-with-command my/fzf-command-default #'fzf/action-find-file path))))


;; (use-package fzf-posframe
;;   :straight
;;   (fzf-posframe
;;     :type git
;;     :host github
;;     :repo "conao3/fzf-posframe.el"))

#+end_src

**** Package: rainbow-mode

#+begin_src emacs-lisp

(use-package rainbow-mode
  :commands (rainbow-mode))

#+end_src

**** Package: visual-fill-column

#+begin_src emacs-lisp

(use-package visual-fill-column
  ;; :defer nil
  :init
  (setq-default truncate-lines t)

  :config
  (defun my/org-mode-visual-fill ()
    (setq visual-fill-column-width          180
          visual-fill-column-center-text    nil)
    (visual-fill-column-mode 1))

  (define-minor-mode line-wrap-mode
    "Toggle line wrap in current buffer.
Org-mode uses visual-fill-column-mode, while every other mode uses the
standard visual-line-mode."
    :local t
    (if line-wrap-mode
        ;; Enable line wrap
        (if (equal major-mode 'org-mode)
            (progn
              (my/org-mode-visual-fill)
              (visual-line-mode 1)
              (setq truncate-lines nil))
          (progn
            (visual-line-mode 1)
            (setq truncate-lines nil)))
      ;; Disable line wrap
      (if (equal major-mode 'org-mode)
          (progn
            (visual-fill-column-mode -1)
            (visual-line-mode -1)
            (setq truncate-lines t))
        (progn
          (visual-line-mode -1)
          (setq truncate-lines t)))))

  :hook
  (org-mode . line-wrap-mode)
  (text-mode . line-wrap-mode)
  (help-mode . line-wrap-mode))

#+end_src

**** Package: highlight-quoted-vars                             :notangle:

#+begin_src emacs-lisp

(use-package init-shell-highlighting
  :straight (init-shell-highlighting
             :type git
             :host github
             :repo "czipperz/highlight-quoted-vars.el"
             :local-repo "highlight-quoted-vars"))

#+end_src

**** Package: hl-todo

It is possible to highlight with background colour instead, but the face used has to be a color, and not a face.

#+begin_src emacs-lisp

(use-package hl-todo
  :hook (prog-mode . hl-todo-mode)
  :config
  (setq hl-todo-keyword-faces
        `(("TODO"       warning bold)
          ("REVIEW"     font-lock-keyword-face bold)
          ("FIXME"      error bold))))

#+end_src

**** Package: fullframe

#+begin_src emacs-lisp

(use-package fullframe
  :config
  (fullframe bufler-list quit-window))

#+end_src

**** Package: rotate

Another alternative is the =transpose-frame= package.

#+begin_src emacs-lisp

(use-package rotate)

#+end_src

**** Package: bm

#+begin_src emacs-lisp

(use-package bm
  :bind
  ("<C-f2>" . bm-toggle)
  ("<f2>"  . bm-next)
  ("<S-f2>" . bm-previous))

;; remove bookmark after jump
;; (setq temporary-bookmark-p t)

#+end_src

** Language Modes

Add support for programming and markup languages in the form of syntax highlighting, code completion, linters, etc.

*** C#
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: csharp-mode

#+begin_src emacs-lisp

(use-package csharp-mode
   :mode ("\\.cs\\'" . csharp-mode)
   :interpreter ("csharp" . csharp-mode))

#+end_src

*** CSV
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: csv-mode

#+begin_src emacs-lisp

(use-package csv-mode
  :mode ("\\.csv\\'" . csv-mode))

#+end_src

*** Dockerfile
**** Features

Basics:
  - [X] syntax highlighting
  - [X] linting
  - [ ] code completion

Extra:
  - image building

**** Package: dockerfile-mode

#+begin_src emacs-lisp

(use-package dockerfile-mode
  :mode "Dockerfile\\'")

(put 'dockerfile-image-name 'safe-local-variable #'stringp)

#+end_src

**** Notes and basic usage

To build a docker image with emacs, use C-d C-b (normally C-c C-b), and add the following to the top of a Dockerfile:

#+begin_example

## -*- dockerfile-image-name: "your-image-name-here" -*-

#+end_example

This variable is declared as safe with the following code, so you aren't asked if it's safe every time you load a Dockerfile.

#+begin_example

(put 'dockerfile-image-name 'safe-local-variable #'stringp)

#+end_example

*** Dotenv
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: dotenv-mode

#+begin_src emacs-lisp

(use-package dotenv-mode
  :mode "\\.env\\..*\\'")

#+end_src

*** Git
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: gitconfig-mode

#+begin_src emacs-lisp

(use-package gitconfig-mode
  :mode ("/\\.gitconfig\\'" "/\\.git/config\\'" "/git/config\\'"
         "/\\.gitmodules\\'"))

#+end_src

**** Package: gitignore-mode

#+begin_src emacs-lisp

(use-package gitignore-mode
  :mode ("/\\.gitignore\\'" "/\\.git/info/exclude\\'" "/git/ignore\\'" "ignore\\'"))

#+end_src

**** Package: gitattributes-mode

#+begin_src emacs-lisp

(use-package gitattributes-mode
  :mode ("/\\.gitattributes\\'"))

#+end_src

*** HTML
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: web-mode

#+begin_src emacs-lisp

(use-package web-mode
  :mode
  (
   "\\.html\\'"
   "\\.vue\\'"
   "\\.blade\\.php\\'"
   )
  :config
  (setq
   web-mode-markup-indent-offset 2
   web-mode-css-indent-offset 2
   web-mode-code-indent-offset 2
   web-mode-style-padding 2
   web-mode-script-padding 2
   web-mode-enable-auto-closing t
   web-mode-enable-auto-opening t
   web-mode-enable-auto-pairing t
   web-mode-enable-auto-indentation t
   web-mode-enable-css-colorization t))

#+end_src

*** Java
**** Features

Basics:
  - [ ] syntax highlighting
  - [ ] linting
  - [ ] code completion

Extra:
  - lsp

**** Package: java-mode+                                        :notangle:

#+begin_src emacs-lisp

(use-package lsp-java
  :ensure nil
  :hook (java-mode . lsp))

#+end_src

*** JSON
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: json-mode

#+begin_src emacs-lisp

(use-package js2-mode
  :mode "\\.json\\'" "\\.js\\'")

#+end_src

*** REVIEW Latex
**** Features

Basics:
  - [ ] syntax highlighting
  - [ ] linting
  - [X] code completion

Extra:
  - references (deactivated)
  - minted code listings

**** Package: company-auctex

#+begin_src emacs-lisp

(use-package company-auctex
  :after company)

#+end_src

**** Package: org-ref                                           :notangle:

This takes a long time to load. Maybe add :mode or :commands to defer loading.

#+begin_src emacs-lisp

(use-package org-ref
  :after org)

#+end_src

**** Latex package: minted                                      :notangle:

Add support for =minted= Latex package.

#+begin_src emacs-lisp

(setq org-latex-listings          'minted
      org-latex-packages-alist    '(("" "minted"))
      org-latex-pdf-process       '("%latex -shell-escape -interaction nonstopmode -output-directory %o %f"
                                    "%latex -shell-escape -interaction nonstopmode -output-directory %o %f"
                                    "%latex -shell-escape -interaction nonstopmode -output-directory %o %f"))

;; (setq org-latex-listings 'minted
;;       org-latex-packages-alist '(("" "minted"))
;;       org-latex-pdf-process
;;       '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
;;         "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))


#+end_src

*** Lua
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: lua-mode

#+begin_src emacs-lisp

(use-package lua-mode
  :mode "\\.lua\\'")

#+end_src

*** Markdown
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: markdown-mode

For markdown, you need to customize the command to run the markdown parser if you use something else.

#+begin_src emacs-lisp

(use-package markdown-mode
  :ensure-system-package (pandoc)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc --css $HOME/.emacs.d/markdown-css/github.css"))

#+end_src

#+begin_src emacs-lisp

;; Fast GitHub-flavored live preview
(use-package vmd-mode
  :ensure-system-package (vmd))

#+end_src

*** PHP
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: php-mode

#+begin_src emacs-lisp

(use-package php-mode
  :mode "\\.php\\'")

#+end_src

*** Shell Script
**** Features

Basics:
  - [ ] syntax highlighting
  - [X] linting
  - [ ] code completion

**** Package: flymake-shellcheck

#+begin_src emacs-lisp

(use-package flymake-shellcheck
  :commands flymake-shellcheck-load
  :init
  (add-hook 'sh-mode-hook 'flymake-shellcheck-load))

#+end_src

*** Python
**** Settings

Prefer Python 3.

#+begin_src emacs-lisp

(setq python-shell-interpreter "python3")

#+end_src

*** Terraform (HCL)
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: terraform-mode

#+begin_src emacs-lisp

(use-package terraform-mode
  :mode "\\.tf\\'")

#+end_src

**** Notes and basic usage

HCL stands for Hashicorp Configuration Language.

*** YAML
**** Features

Basics:
  - [X] syntax highlighting
  - [ ] linting
  - [ ] code completion

**** Package: yaml-mode

#+begin_src emacs-lisp

(use-package yaml-mode
  :mode "\\.y\\(a\\)?ml\\'")

#+end_src

** Personal Settings

Load personal settings file if it exists.
This is where you put sensitive information like emails and credentials.
Remember to add this file to =.gitignore=.

#+begin_src emacs-lisp

(let ((personal-settings (expand-file-name "personal.el" user-emacs-directory)))
 (when (file-exists-p personal-settings)
   (load-file personal-settings)))

#+end_src

** Experimental Snippets + Work in Progress

This section has random code snippets and unfinished ideas.
None of these is exported to the config file. Eventually, these ideas should be finished and implemented or deleted.
They are in the end of the config file to allow most of the config to be loaded even if there's an error.

*** org beautify symbols                                         :notangle:

#+begin_src emacs-lisp

(use-package org
  :hook ((org-mode . (lambda ()
                       ;; "Beautify Org Checkbox Symbol"
                       (push '("[ ]" .  "☐") prettify-symbols-alist)
                       (push '("[X]" . "☑" ) prettify-symbols-alist)
                       (push '("[-]" . "❍" ) prettify-symbols-alist)
                       ;; replace text of org blocks with symbols
                       (push '("#+BEGIN_SRC" . "↦" ) prettify-symbols-alist)
                       (push '("#+END_SRC" . "⇤" ) prettify-symbols-alist)
                       (push '("#+BEGIN_EXAMPLE" . "↦" ) prettify-symbols-alist)
                       (push '("#+END_EXAMPLE" . "⇤" ) prettify-symbols-alist)
                       (push '("#+BEGIN_QUOTE" . "↦" ) prettify-symbols-alist)
                       (push '("#+END_QUOTE" . "⇤" ) prettify-symbols-alist)
                       (push '("#+begin_quote" . "↦" ) prettify-symbols-alist)
                       (push '("#+end_quote" . "⇤" ) prettify-symbols-alist)
                       (push '("#+begin_example" . "↦" ) prettify-symbols-alist)
                       (push '("#+end_example" . "⇤" ) prettify-symbols-alist)
                       (push '("#+begin_src" . "↦" ) prettify-symbols-alist)
                       (push '("#+end_src" . "⇤" ) prettify-symbols-alist)
                       (prettify-symbols-mode)))))

#+end_src

*** word navigation                                              :notangle:

navigate words by only moving to the first character, backward and forward

#+begin_src emacs-lisp

(progn
  (defun boundary ()
    (and      (= (char-syntax (char-after))  ?w)
         (not (= (char-syntax (char-before)) ?w))))
  (defun my-forward-word ()
    (interactive)
    (while (progn (forward-char)  (not (boundary)))))
  (defun my-backward-word ()
    (interactive)
    (while (progn (backward-char) (not (boundary)))))
  (global-set-key [M-right] 'my-forward-word)
  (global-set-key [M-left]  'my-backward-word)
  )

(bind-key "M-<left>" 'my-backward-word wakib-keys-overriding-map)
(bind-key "M-<right>" 'my-forward-word wakib-keys-overriding-map)

#+end_src

*** stuff I need to try that might improve scrolling.            :notangle:

#+begin_src emacs-lisp

(use-package emacs
  :custom
  ;; https://www.masteringemacs.org/article/improving-performance-emacs-display-engine
  ;; https://www.reddit.com/r/emacs/comments/8sw3r0/finally_scrolling_over_large_images_with_pixel/
  ;; https://www.reddit.com/r/emacs/comments/9rwb4h/why_does_fast_scrolling_freeze_the_screen/
  ;; https://emacs.stackexchange.com/questions/10354/smooth-mouse-scroll-for-inline-images
  ;; https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag
  (redisplay-dont-pause            t) ;; Fully redraw the display before it processes queued input events.
  (next-screen-context-lines       2) ;; Number of lines of continuity to retain when scrolling by full screens
  (scroll-conservatively         101) ;; only 'jump' when moving this far off the screen
  (scroll-step                     1) ;; Keyboard scroll one line at a time
  (mouse-wheel-progressive-speed nil) ;; Don't accelerate scrolling
  (mouse-wheel-follow-mouse        t) ;; Scroll window under mouse
  (fast-but-imprecise-scrolling    t) ;; No (less) lag while scrolling lots.
  (auto-window-vscroll           nil) ;; Cursor move faster
  )

;; Inertial Scrolling - Better than progressive-speed
(use-package inertial-scroll
  :straight t
  :custom
  (inertias-friction 110)
  :bind
  (("<mouse-4>"     . inertias-down-wheel) ;; Replace mwheel-scroll
   ("<mouse-5>"     . inertias-up-wheel  ) ;; Replace mwheel-scroll
   ("<wheel-up>"    . inertias-down-wheel)
   ("<wheel-down>"  . inertias-up-wheel  )))

;; Pixel-scroll alternative
(use-package good-scroll
  :straight (good-scroll :type git :host github :repo "io12/good-scroll.el")
  :hook (after-init . good-scroll-mode))

#+end_src

*** make tab-line empty                                          :notangle:

#+begin_src emacs-lisp

;; use this next snippet to add blank space at the top of the window
;; note: the background should be set to the same as the buffer
(setq header-line-format " ")

;; another option is to use the tab-line. Just give the function responsible for tab names an error and the tab line will be empty.

#+end_src

*** Emacs server                                                 :notangle:

Detect existing emacs server and switch to it if possible

#+begin_src emacs-lisp

(require 'server)

(defun my-server-shunt ()
  "Shunts to emacsclient"
  (let ((args (append '("emacsclient" "-a" "\"\"" "-n")
                      (cdr command-line-args))))
    (shell-command (substring (format "%S" args) 1 -1))
    (kill-emacs)))

;; Keep only one Emacs server instance
(if (server-running-p)
    (if (daemonp)
        (error "Another running Emacs server detected, abort")
      (my-server-shunt))
  (server-start))

#+end_src

*** system notifications                                         :notangle:

#+begin_src emacs-lisp

(use-package alert
  :ensure t
  :config
  (setq alert-default-style 'libnotify))

#+end_src

*** ledger                                                       :notangle:

#+begin_src emacs-lisp

(use-package ledger-mode
  :ensure nil
  :mode ("\\.ledger\\'" . ledger-mode)
  :config
  (use-package flycheck-ledger
    :ensure t))

#+end_src

*** agenda todo list - ignore scheduled and deadline             :notangle:

#+begin_src emacs-lisp

;; don't show tasks that are scheduled or have deadlines in the normal todo list
(setq org-agenda-todo-ignore-deadlines (quote all))
(setq org-agenda-todo-ignore-scheduled (quote all))

#+end_src

*** export org agenda to .ics file for Google calendar           :notangle:

#+begin_src emacs-lisp

(setq org-icalendar-combined-agenda-file "~/tmp/org-agenda-export.ics"
      org-icalendar-use-scheduled        '(event-if-todo-not-done)
      org-icalendar-use-deadline         '(event-if-todo-not-done))

(org-icalendar-combine-agenda-files)

#+end_src

*** dired-sidebar test                                           :notangle:

#+begin_src emacs-lisp

(use-package dired-sidebar
  :commands (dired-sidebar-toggle-sidebar)
  :init
  (add-hook 'dired-sidebar-mode-hook
             (lambda ()
               (unless (file-remote-p default-directory)
                 (auto-revert-mode))))

  :config
  ;; (setq dired-sidebar-should-follow-file t)
  ;; (setq dired-sidebar-theme 'icons)
  (setq dired-sidebar-theme 'ascii)
  (setq dired-sidebar-one-instance-p t)
  (setq dired-sidebar-no-delete-other-windows t)
  ;; (setq dired-sidebar-refresh-on-projectile-switch t)

  ;; (defun my/bufler-sidebar-advice ()
  ;;   (dired-sidebar-follow-file))
  ;; (advice-add 'bufler-list-buffer-switch :after #'my/bufler-sidebar-advice)

  (defun my/dired-sidebar-focus-bufler (a)
    "Make dired-sidebar focus current bufler workspace."
    (with-current-buffer (car (bufler-workspace-buffers))
      (let ((root (dired-sidebar-get-dir-to-show)))
        (dired-sidebar-switch-to-dir root))))

  :hook
  (dired-sidebar-mode . (lambda () (display-line-numbers-mode -1)))
  (dired-sidebar-mode . hide-mode-line-mode)
  (bufler-workspace-set-hook . my/dired-sidebar-focus-bufler))

;; (use-package all-the-icons-dired)
;; (dired-sidebar-switch-to-dir "~/")

;; (custom-set-faces
;;  '(doom-modeline-buffer-modified      ((t (:foreground "#ff0000")))))

;; (push '(bufler-list-buffer-switch . 1) dired-sidebar-special-refresh-commands)

;; (bufler-buffers)
;; (bufler-group-tree-paths (bufler-buffers))

;; (add-hook 'bufler-workspace-set-hook
;;   (lambda () (projectile-switch-project-by-name (projectile-project-name))))

;; (projectile-project-name)

;; (bufler-workspace-focus-buffer BUFFER)



;; (defun my/bufler-advice (buffer)
;;   (projectile-project-name buffer))

;; (projectile-project-name)

;; (advice-add 'bufler-workspace-focus-buffer :after #'my/bufler-advice)


;; (dired-sidebar-switch-to-dir (dired-sidebar-get-dir-to-show))

#+end_src

*** indent guides                                                :notangle:

=highlight-indent-guides= with =character= method seems like the best option.

#+begin_src emacs-lisp

(use-package highlight-indentation
  :config
  (setq highlight-indentation-blank-lines t)
  (custom-set-faces
   '(highlight-indentation-current-column-face  ((t (:background "#ffa500"))))
   '(highlight-indentation-face                 ((t (:background "#17162a"))))))


(use-package indent-guide
  :config
  (indent-guide-global-mode))


(use-package hl-indent
  :config
  (setq highlight-indent-guides-method 'bitmap))


(use-package highlight-indent-guides
  :config

  ;; option 1
  (setq highlight-indent-guides-method 'character)

  ;; option 2
  (setq highlight-indent-guides-method 'bitmap)
  (setq highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line)

  :hook
  (prog-mode . highlight-indent-guides-mode))

#+end_src

*** company-flyspel.el                                           :notangle:

#+begin_src emacs-lisp

;;; company-flyspell.el --- company-mode flyspell backend -*- lexical-binding: t -*-

;; Copyright (C) 2016 Free Software Foundation, Inc.

;; Author: Henry G. Weller

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.


;;; Commentary:
;;

;;; Code:

(require 'company)
(require 'cl-lib)
(require 'flyspell)

(defgroup company-flyspell nil
  "Completion backend using flyspell."
  :group 'company)

(defvar company-flyspell-available 'unknown)

(defun company-flyspell--lookup-words (word)
  "Return a list of possible corrections for misspelled WORD.
Based on `flyspell-correct-word-before-point'."
  ;; use the correct dictionary
  (flyspell-accept-buffer-local-defs)
  (let (words ispell-filter)
    ;; now check spelling of word.
    (ispell-send-string "%\n")  ; put in verbose mode
    (ispell-send-string (concat "^" word "\n"))
    ;; wait until Aspell has processed word
    (while (progn
             (accept-process-output ispell-process)
             (not (string= "" (car ispell-filter)))))
    ;; Remove leading empty element
    (setq ispell-filter (cdr ispell-filter))
    ;; ispell process should return something after word is sent.
    ;; Tag word as valid (i.e., skip) otherwise
    (or ispell-filter
        (setq ispell-filter '(*)))
    (if (consp ispell-filter)
        (setq words (ispell-parse-output (car ispell-filter))))
    (cond
     ((or (eq words t) (stringp words))
      ;; don't correct word
      (list word))
     ((null words)
      ;; ispell error
      (error "Ispell: error in Ispell process")
      nil)
     (t
      ;; The word is incorrect, return list of alternatives
      (nth 2 words)))))

(defun company-flyspell-available ()
  (when (eq company-flyspell-available 'unknown)
    (condition-case _err
        (progn
          (company-flyspell--lookup-words "WHATEVER")
          (setq company-flyspell-available t))
      (error
       (message "Company: flyspell-look-command not found")
       (setq company-flyspell-available nil))))
  company-flyspell-available)

;;;###autoload
(defun company-flyspell (command &optional arg &rest ignored)
  "`company-mode' completion backend using flyspell."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'company-flyspell))
    (prefix (when (company-flyspell-available)
              (company-grab-word)))
    (candidates (company-flyspell--lookup-words arg))
    (sorted t)
    (ignore-case nil)))

(provide 'company-flyspell)
;;; company-flyspell.el ends here

#+end_src

*** dired-sort-menu                                              :notangle:

Allows sorting of items while in a dired buffer

#+begin_src emacs-lisp

(use-package dired-sort-menu)

;; This one seems nicer. Just press "S" to open a hydra menu and select how to sort.
(use-package dired-quick-sort
  :config
  (dired-quick-sort-setup))

#+end_src

*** check host OS                                                :notangle:

These variable is for handily tangle blocks on different OSes.

#+begin_src emacs-lisp

(set 'linuxp (when (eq system-type 'gnu/linux) "yes"))
(set 'windowp (when (eq system-type 'windows-nt) "yes"))

#+end_src

*** format org files - move planning to top of heading           :notangle:

This doesnt work as it is now because ~(org-at-planning-p)~ only returns true when the text is in the first line of the heading.

Explanation:
  Usually, org planning lines (Scheduled, Deadline, etc.) should be the first thing in a heading.
  Any drawers, such as the properties drawer, should only appear afterwards.

#+begin_src emacs-lisp

(defun my/org-move-planning-lines-top-of-heading ()
  "Move any present planning lines to top of current heading.
Preserves ordering"
  (interactive)
  (let ((start (org-entry-beginning-position))
        (end (org-entry-end-position))
        (match-list (list)))

    (forward-line)
    (setq first-line (line-number-at-pos))

    (while (not (org-at-heading-p))
      (if (org-at-planning-p)
          (append (line-number-at-pos) match-list))
      (forward-line))

    (setq original-lst-length (length match-list))

    (while (> (length match-list) 0)
      (setq iterations (- original-lst-length (length match-list)))
      (setq match-line (+ (pop match-list) iterations))
      (goto-line match-line)
      (drag-stuff-up (- val first-line)))))

#+end_src

*** Color theme examples and research

Resources:
- https://vimcolorschemes.com/
- https://github.com/pineapplegiant/spaceduck#emacs
- https://ciembor.github.io/4bit/

Finish later:
- https://vimcolorschemes.com/artanikin/vim-synthwave84
- https://vimcolorschemes.com/ghifarit53/tokyonight-vim
- https://vimcolorschemes.com/wadackel/vim-dogrun
- https://vimcolorschemes.com/pineapplegiant/spaceduck
- https://vimcolorschemes.com/glepnir/oceanic-material
- https://vimcolorschemes.com/dracula/vim
- https://vimcolorschemes.com/reedes/vim-colors-pencil
- https://packagecontrol.io/packages/DinkDonk%20Color%20Scheme


| Theme             | bg      | red     | green   | yellow  | blue    | magenta | cyan    | fg      |
|-------------------+---------+---------+---------+---------+---------+---------+---------+---------|
| embark            | #1e1c31 | #f48fb1 | #a1efd3 | #ffe6b3 | #91ddff | #d4bfff | #87dfeb | #cbe3e7 |
| snazzy            | #1e1f29 | #da514d | #51e88e | #eead0d | #80c1cf | #b45391 | #3aa0e8 | #b7b7bf |
| pop-punk          | #000000 | #d50f62 | #43d726 | #fd9c27 | #168fc0 | #9e2ccb | #4adfd0 | #ffffff |
| challenger-deep   | #1a172b | #ff5458 | #62d196 | #ffb378 | #65b2ff | #906cff | #63f2f1 | #a6b3cc |
| kabukicho-vscode  | #130d1a | #f829ac | #5df390 | #fdca00 | #5d6dc7 | #9963ff | #60e1fe |         |
|                   |         |         |         |         |         |         |         |         |
| vim-synthwave84   |         |         |         |         |         |         |         |         |
| tokyonight-vim    |         |         |         |         |         |         |         |         |
| vim-dogrun        |         |         |         |         |         |         |         |         |
| dogrun            |         |         |         |         |         |         |         |         |
| oceanic-material  |         |         |         |         |         |         |         |         |
| vim-dracula       |         |         |         |         |         |         |         |         |
| vim-colors-pencil |         |         |         |         |         |         |         |         |
|                   |         |         |         |         |         |         |         |         |
| test              |         | #ff1493 | #12F292 | #ffa500 | #4c83ff | #A840F4 | #21D7D7 |         |


custom theme ideas:
  - deep
  - ocean
  - dark
  - neon
  - space
  - navy
  - sun


space-navy
neon-ocean
neon-waves
neon-sea
neon-ocean-sunset

*** Vim and Ryo-modal keybindings
**** vim keys

h,j,k,l

left-char
right-char
previous-line
next-line

^,$,C-b,C-f

beginning-of-line
end-of-line
scroll-up-command
scroll-down-command

b,w,{,}

backward-word
forward-word
backward-paragraph
forward-paragraph

%,]),]}

backward-sexp
forward-sexp
backward-up-list
down-list

":m .+1", ":m .-1", <, >

drag-stuff-left
drag-stuff-right
drag-stuff-up
drag-stuff-down

**** ryo-modal test

j,i,k,l

left-char
right-char
previous-line
next-line

u,o

scroll-up-command
scroll-down-command

U,O

beginning-of-line
end-of-line

J,I,K,L

backward-word
forward-word
backward-paragraph
forward-paragraph

p,+,P,* (alternative for: [,],{,})

backward-sexp
forward-sexp
backward-up-list
down-list

M-(j,i,k,l)

drag-stuff-left
drag-stuff-right
drag-stuff-up
drag-stuff-down

*** Git Graph                                                    :notangle:

Provides magit-pg command.

#+begin_src emacs-lisp

(use-package magit-pretty-graph
  :straight
  (magit-pretty-graph :type git :host github :repo "georgek/magit-pretty-graph"
                      :fork (:host github :repo "AkibAzmain/magit-pretty-graph"))
  :config
  (defun my/magit-pretty-graph-project ()
    "Calls ~magit-pg-repo~ for current project root."
    (interactive)
    (magit-pg-repo (projectile-project-root))))

#+end_src

*** bookmarks and marks

Available packages:
  - bm
  - goto-last-change
  - point-pos
  - point-stack
  - back-button

*** experimental keybind changes

emacs mark (pop, push) -> C-', C-" (or Meta key)
company -> C-SPC

*** Theme Faces and Colours                                      :notangle:

How to edit a theme:

#+begin_src emacs-lisp

(setq custom--inhibit-theme-enable nil)

(with-eval-after-load "underwater-theme"
  (let ((bg_1      "#000000")
        (fg_1      "#ffffff"))
    (custom-theme-set-faces
     'underwater

     ;; you can set variables and use them, use the colors directly, or use Emacs default colors
     `(default                       ((t (:background ,bg_1 :foreground ,fg_1))))
     '(region                        ((t (:background "#888888"))))
     '(region                        ((t (:background "cyan"))))

     )))

#+end_src

** File Footer

#+begin_src emacs-lisp

;;; config.el ends here

#+end_src

* Fixes, Improvements and TODOs

Todo:
  - [X] workspaces in dashboard
  - [X] org mode: when pressing enter at the end of line that starts with '-', it adds two spaces
  - [X] setting scroll margin messes up org indent mode. the first/last line sometimes appears un-indented
  - [X] change project name in the modeline (the name itself + its appearance)
  - [X] change org source block header highlight color
  - [X] home key should toggle between row 0 and first character in line (beginning and indentation, in emacs terms)
  - [X] when line number is 0-9, and it changes to a greater value, the numbers column width changes and the whole buffers moves.
  - [X] disable completion for plain text modes (org-mode)
  - [X] config file should open with 2 levels of headings
  - [X] add tabs like Sublime Text or somehow show tabs in current project
  - [X] disable tab-line in dashboard
  - [X] hidden tab-bar reappears when doing: M-x ESC
  - [X] mode-line lighter for current indentation settings isn't there anymore
  - [X] add icon to custom projectile doom-modeline segment
  - [X] workspaces in dashboard icon
  - [X] org-indent messes up hl-line-mode. it only has one face for the indentation. this creates a gap from line number to line. fix by changing bg of curr line number
  - [X] background colour of org document keywords is not the same as normal background
  - [X] ctrl+shift+left/right doesnt work
  - [X] a hex color should count as a full word when selecting it (double click or C-S-left/right) (disable subword navigation)
  - [X] selecting with S-<home> and pressing delete only removes indentation (untabify)
  - [X] make alt+arrow work in org mode for headlines without shift (custom function)
  - [X] use straight.el so only packages declared in the config file are loaded
  - [X] compare latest version with old version in git. load time went from 0.7-0.8 -> 1.0-1.2 seconds.
  - [X] package-quickstart needs to be deleted after package update or else there's an error. sometimes also custom.el
  - [X] arrow indicating visual line doesn't appear
  - [X] figure out how to deal with new file (C-n) while using bufler groups
  - [X] bufler groups show same file 2 times, in its own group and without a group
  - [X] make C-backspace delete until first non whitespace character
  - [X] make new line indicator appear only on right fringe
  - [X] bufler workspace name in modeline doesn't fade to grey in inactive window
  - [X] magit and dired buffers end up without  any bufler workspace
  - [X] C-k should not copy to clipboard
  - [X] make visual-regexp work with active region as input
  - [X] org-indent sometimes does not indent the top-most line in the buffer (looks like changing line numbers font height fixed it)
  - [X] add projectile hydras
  - [X] add treemacs hydras
  - [X] query-replace with current selection as input (Replace+ package maybe?)
  - [X] M-o isnt working for C-o and flyspell-correct
  - [X] why does reloading the init file mess up doom-modeline (and why does it only happen in the currently open buffer)
  - [X] when dashboard is opened with a hydra, the hydra menu stays open
  - [X] for every package, use as much use-package integration as possible
  - [X] C-backspace deletes previous word. it should only delete whitespace
  - [X] swiper sometimes shows the match behind the modeline
  - [X] regarding doom-modeline buffer name segment, when the file is deleted and there is a forbidden icon, there should be an extra space before it.
  - [X] do not show selection segment in modeline when clicking with the mouse
  - [X] add shortcuts for dashboard and init file (maybe hydras)
  - [X] new keybindings for project find and project replace
  - [X] remove dashboard from initial bufler group
  - [X] change bufler group for dashboard and magit-status
  - [X] swiper always uses multiple cursor after pressing RET. Not using C-m as the keybind fixes it.
  - [X] replace org-bullets with org-superstar
  - [X] look at other modelines (spaceline and telephone-line)
  - [X] being able to change the directory of a search (C-S-f)
  - [X] make a hydra for my/org-latex-compile-and-open-pdf, org-sort, and org-goto
  - [X] make pdf-tools work with scroll-other-window (M-<page_up/down>)
  - [X] make untitled buffers appear in the 'All files' bufler group, and also in the respective project subgroup, if it exists
  - [X] add indentation hydra
  - [X] org-mode unordered lists should also have bullets (org-superstar seems to solve this)
  - [X] make org-mode unordered lists use bullets as symbols, and remove the bullets from the orgmode headings
  - [X] alt-shift-up/down conflict in org mode with multiple cursors (mc bind disabled for now)
  - [X] add function to move line with current cursor to top of screen
  - [X] do something about keybinds that put the cursor in the center/top of the screen
  - [X] add C-S-s (save all)
  - [X] add functions converting indentation to tabs/spaces
  - [X] finish functions in indentation hydra (convert and set indentation width)
  - [X] add function to navigate cursor to matching parenthesis, when on top of one
  - [X] add function to delete everything between current parenthesis and its pair
  - [X] counsel-find-file should show folders before files
  - [X] make ivy ignore order of tokens
  - [X] improve swiper regex groups colours for matches
  - [X] make C-f and C-h use similar colors
  - [X] apostrophes should not be selected when selecting words
  - [X] show-paren-mode has issues in org-mode when encountering these symbol: "<" and ">"
  - [X] apparently, the lines with "(modify-syntax-entry ?< ".")" are not being evaluated
  - [X] when flyspell is active, show indicator, along with selected dictionary language
  - [X] add hydra to change dictionary language
  - [X] use hydra posframe
  - [X] add bookmarks hydra
  - [X] use C-t to show list of functions/symbols
  - [X] C-k with region selected should also delete the line
  - [X] commenting a region should comment all lines at the beginning of the line
  - [X] vr/replace doesnt auto open org headings (anzu can do it, but it has worse syntax. solved by unfolding the entire file)
  - [X] replace "cua-selection-mode" with "set-rectangular-region-anchor" from "rectangular-region-mode" (figure out what's the best option)
  - [X] add option to load previous session on startup (button on dashboard) (use desktop+.el ?) (how does doom-emacs do it?)
  - [X] dashboard appears in the buffer switch menu (C-b) after opening it with the hydra. It disappears after switching between two buffers in the workspace.
  - [X] check if I can do anything with "force-mode-line-update" for updating dictionary modeline segment
  - [X] dired buffers dont have a group in bufler
  - [X] when using F3 search, check if there's an active region
  - [X] clean up the final section of the config file
  - [X] when I save the config file, a dired-mode *Find* buffer appears
  - [X] use flycheck for elisp (for config file)
  - [X] C-tab = tab-recent doesnt work (also for C-S-tab)
  - [X] ryo-modal messes up C-up and M-Return, in org-mode (happens when loaded before org package)
  - [X] restore bufler workspaces when restoring the session
  - [X] F3 should not start a new search, but always go back to the previous one
  - [X] add margin to the left of org-agenda (between category and todo) (org-agenda-prefix)
  - [X] see if it's possible to remove =*special*= buffers from =C-b=
  - [X] add margin to right side of org source blocks
  - [X] add functions and hydras to convert line endings
  - [X] change C-SPC to do something related to jumping to bookmarks, previous mark location, or something like that
  - [X] remove tab-line from bufler, magit, and any other like them
  - [X] add help hydra to describe functions at point
  - [X] spellcheck modeline segment dissapears when linter is active (confirmed not working in a Dockerfile)
  - [X] when in a bufler named workspace, new opened buffers are added to the default workspace, instead of the opened workspace
  - [X] add some sort of agenda view where I can see tasks without dates (or improve current agenda view)
  - [X] dashboard agenda shows archived tasks
  - [X] add =:ensure-system-package= and more dependencies to use-package declarations
  - [X] use minted for latex listings
  - [X] some functions have package dependencies and shouldnt be in the Functions section
  - [X] ivy-yasnippet "src" snippet gives warning because the snippet declaration file has extra spaces
  - [X] add window hydra with functions: maximize, minimize and balance
  - [X] bufler-list space between sections =bufler-list-group-separators= (https://github.com/alphapapa/bufler.el/issues/7)
  - [X] fzf-directory - completion works poorly (uses ido completion by default)
  - [X] make treemacs change directory when doing bufler focus workspace
  - [X] change treemacs project root faces (remove underline)
  - [X] highlight whitespace on active selection
  - [X] bufler - make scratch buffer accessible to all projectile groups
  - [X] pg-up pg-down should return cursor to same place in document
  - [X] bufler frame title (add =-- Emacs=)
  - [X] C-c doesn't work in llncsorg-master Makefile
  - [X] make the bufler focus function also change the sidebar directory
  - [X] frame title stopped working after patching split-window-sensibly (maybe some bufler-list hook?)
  - [X] when opening a treemacs workspace in dashboard, it should ask for a file
  - [X] add snippets to hydra-insert, if yasnippet starts being used
  - [X] bufler file list (<menu>-b-b): reorganize /special/ and /help/ so that one has things that I can delete at any time and the other is essential
  - [X] ctrl+shift+o to open directory in sidebar (or use dired instead)
  - [X] error indicator in fringe for flyspell and flycheck
  - [X] git gutter on left and flycheck gutter on right side
  - [X] make it possible to see git gutter, company errors and visual line arrows all at the same time, without conflicts
  - [X] change frame title without changing bufler workspace name (-- Emacs)
  - [X] add hook to display-line-numbers-mode to also add a 1 unit margin
  - [X] make bufler-list buffer open in full frame size
  - [X] toggles hydra: add toggle for toggle-menu-bar
  - [X] allow jumping between git hunks (git-gutter) or modified buffer areas
  - [X] highlight FIXME, TODO, etc
  - [X] C-l in a side window affects the left window instead
  - [X] opening a new file in terminal or explorer should add a new buffer to existing emacs frame (maybe use emacsclient)
  - [X] M-left/right quits selection after moving only once when there is a region selected
  - [X] diff-hl activation - global mode vs prog-mode hook
  - [X] add diff section to magit hydra
  - [X] change how org mode treats comments. /comment-line/ should not comment the current heading
  - [X] org-toggle-comment is not the desired behaviour for C-/
  - [X] give every doom modeline segment a mouse-over description and menu (tooltip)
  - [X] some buffers (like rg search, shell-process) show indicators on left fringe
  - [X] org-mode - when commenting inside a heading, the heading receives a 'COMMENT' todo item instead
  - [X] modeline gets off-screen when filename is too large
  - [X] left-fringe-width conflict with visual-line-mode indicators
  - [X] "my/open-file-from-org-dir" has a different menu the first time it's called. it changes after selecting an option once.
  - [X] when a region is selected and an arrow key is pressed in the opposite direction, exchange point and cursor (or make jump to prev mark work)
  - [X] disable line wrap for coding and enable for org mode
  - [X] add line wrap to toggles hydra
  - [X] jump to new window when a window is created
  - [X] incompatibility between =my/async-babel-tangle= and =org-babel-tangle-collect-blocks=
  - [X] =org-babel-tangle-collect-blocks= will not allow =my/async-babel-tangle= to load if there is an error on the config file
  - [X] switch window positions between them
  - [X] =org-babel-tangle-collect-blocks= will not work the first time =init.el= is loaded
  - [X] create a =diff= hydra
  - [X] some items in the toggles hydra dont change icon when toggled
  - [X] auto switch to new window is annoying when used with company (first line in file opens full report) or magit (C-d C-c commit opens new commit diff window)
  - [X] add a =M-SPC f z= command that uses fzf and shows every file, including git ignored ones.
  - [X] convert my colour options into a standard Emacs color theme
  - [X] Makefile mode can't use C-c to copy (happens when =yas--direct-makefile-gmake-mode= is set to t)
  - [X] hydra toggle for golden-ratio-mode
  - [X] magit diffs use blue and pink for additions and deletions
  - [X] there's some sort of problem with fonts (Cartograph not detected; M-x menu font size)
  - [X] hydra toggle menu - add a toggle for a side panel (in the right), that allows jumping to functions
  - [X] C-<mouse-1> doesn't work
  - [ ] add keybindings tables (or a cheatsheet image) in config file
  - [ ] commenting/indenting inside source block jumps to top of block. happens with just 'emacs -Q' and comment-dwim ([[https://www.reddit.com/r/emacs/comments/ap4s7z/orgmode_weirdness_questions/][reddit thread]])
  - [ ] maybe incorporate previous/next concept from wakib-emacs? (it uses the ';' key)
  - [ ] use 'C-.' to fix any type of error (flycheck/flyspell)
  - [ ] allow C-page up/down to cycle when at first/last tab (setting =tab-line-switch-cycling= to =t= will be able to do this in a future patch)
  - [ ] use smerge hydra for better merging conflict resolution (https://github.com/alphapapa/unpackaged.el#hydra)
  - [ ] improve appearance of tab-line backward and forward buttons (they appear when the bar is too full)
  - [ ] for every package, add a quote from their git repo explaining what the package does
  - [ ] allow jumping to a function definition by ctrl-click or f2 or something else (check 'embark' package)
  - [ ] add hydra or M-<key> commands for org-mark-ring-push, org-mark-ring-goto, counsel-mark-ring
  - [ ] C-SPC and C-u SPC don't work with ryo-modal (C-SPC C-SPC to mark, C-u C-SPC to jump to prev mark)
  - [ ] golden-ratio seems to be interfering with which-key
  - [ ] try out =calfw= package
  - [ ] reduce font size for hydra menus (should see menus even at 60% window width) (it's very hard to read the text when window size is too small)
  - [ ] crux has a lot of useful commands. I could replace some of my custom functions with their package.
  - [ ] rainbow-mode gets overshadowed by current line highlighting
  - [ ] electric-indent-mode in gitconfig-mode adds unnecessary tab after RET
  - [ ] divide org-agenda NEXT section into sections based on different projects, and show warning if no NEXT action exists for a project
  - [ ] can't customize emacs variables because of =wakib-keys= package
  - [ ] open function help buffer -> click link to go to definition -> opens with cursor on top of function, at bottom of window. Should open on top of window instead. (=find-function-search-for-symbol= does not use ~(recenter find-function-recenter-line)~, unlike =find-function=)
  - [ ] make 'my/indent-region-custom' function (M-arrows) work even in a blank line (could try 'indent-to' function)
  - [ ] select region and press '(' to surround in parens; doesnt work in YAML mode
  - [ ] add a keybinding for 'counsel-company' (maybe =C-SPC=?)
  - [ ] make auto-correct work like in google docs (suggestion appears automatically; press tab to open menu; use tab to move in menu; menu has these buttons: most likely correction, cancel, save, more options) [[https://gist.github.com/aaronjensen/a46f88dbd1ab9bb3aa22][link1]] [[https://github.com/company-mode/company-mode/wiki/Switching-from-Vim][link2]]
  - [ ] add support for /.editorconfig/
  - [ ] replace dired keybindings with a better version (and also dired-sidebar)
  - [ ] after opening bufler with =M-SPC b b= (bufler-list), the previous window layout is deleted and only a single window is visible
  - [ ] use [[https://github.com/lepisma/org-books][org-books]] as template to create an org capture template for anime, manga, movies, books, etc.
  - [ ] diff-hl seems to sometimes cause the lines to align to the left, when moving up or down (either by scrolling line by line or with pgUp/pgDown)
  - [ ] yascroll was disabled, but I don't remember why. I'll reactivate it and see if anything bad happens.
  - [ ] change colors or org headings to something more neutral
  - [ ] use C-. for spelling and C-spc for completion. Figure out how to replace C-u C-spc (pop-to-mark-command / set-mark-command)
  - [ ] change theme faces for latex mode
  - [ ] add a modeline indicator to indocate if =company= is active
  - [ ] figure out what to do with =C-u=, =C-SPC C-SPC= and with marks in general. should also pick one of the packages in the experimental area.
  - [ ] figure out what to do with =C-SPC=, =ryo-modal=, and =flycheck=
  - [ ] allow selecting an entire line, or duplicating an entire line
  - [ ] allow moving the window by a single line up or down (like VSCode)
  - [ ] make =swiper-mc= work on C-r or combine C-f with C-r better
  - [ ] when trying to use fzf on home directory, it searches for commands instead of files. This is fine, but it should be more transparent.
  - [ ] bug - every time I switch to a new file, its name goes into the clipboard (problem is my/org-fontify-simple-headlines -> my/show-buffer-name -> kill-new)
  - [ ] need to have some way to navigate to previous/next in flycheck, flyspell, and diff-hl


# NOTE: use org-sort and select 'X' to sort this list by what items are checked


add documentation:
  - [X] (in org mode) M-left/right -> promote/demote single heading; M-S-left/right -> promote/demote heading subtree
  - [X] C-RET and C-S-RET to make newlines (add keybinding docs)
  - [X] C-t "go to symbol", C-p "go to file" (add to keybindings documentation)
  - [ ] add something about how to use base/utils/emacs-server.sh
  - [ ] add =emacs= and =emacs-distributions= tags to git repo, when the time is appropriate


from sublime:
  - [X] use vertical lines to signal indentation
  - [X] markdown preview (in browser) asks you what flavour to use
  - [X] diff files
  - [X] file - reveal in sidebar
  - [X] convert unicode to escaped string back and forth
  - [X] open external terminal in current directory
  - [X] using git - compare file against commit
  - [X] C-- comment, C-S-- block comment
  - [X] highlight vertical indentation of current scope / show bracket symbol in gutter (start and end of scope)
  - [X] show git untracked/unstaged/staged number in the modeline segment (also N of commits ahead/behind)
  - [X] bookmarks (C-F2 toggle, F2 next, S-F2 prev, C-S-F2 clear all, M-F2 select all)
  - [X] notifications plugin
  - [ ] C-F6 for spellcheck, F6 for next error
  - [ ] snippet shows in autocomplete menu (integrate company and yasnippet). just type and use tab for autocomplete. then use tab to jump in next snippet position
  - [ ] jumping to start/end and PG-up/down all use smooth scrolling


from VSCode:
  - [ ] automatically create =.gitignore= files, after selecting project languages


long term goals:
  - [ ] look at vscode settings + extensions and import anything I like
  - [ ] when this config is developed enough, see what it needs to work on Windows
  - [ ] occasionally go through all the packages, and enable use-package defer features when possible, to keep startup time under 1 second
